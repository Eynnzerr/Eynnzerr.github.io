<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eynnzerr&#39;s Blog 复活</title>
    <url>/2025/08/29/hello-world/</url>
    <content><![CDATA[<p>在还是懵懂的大一本科生时，曾经折腾过一台服务器部署了一个博客网站，保持过一年的更新，最终却并未坚持下去。博客废弃了，域名早已过期，服务器也停机释放了。</p>
<p>三年后的今天，在整理旧电脑的数据时，无意间看到了曾经写过的几篇内容。也许文笔稚嫩，也许技术力尚欠缺，却一瞬间将我带回从前，那段时光中，最勤奋好学，贪婪地汲取知识，期待着变强的自己。</p>
<p>果然，博客还是要做下去。当再度萌生这个想法时，这个新的站点就诞生了。为了追求快速部署，采用了<strong>Github Pages</strong> + <a href="https://github.com/hexojs/hexo">Hexo</a>，主题暂且还是使用了烂大街但是确实很简约耐看的<a href="https://github.com/next-theme/hexo-theme-next">Next</a>。我会像从前一样，在这里记录自己的技术学习与实践经验，不仅为自己的反思总结，如果能帮到一些人那便更好。目前我会先对保留的老博客文章作筛选，将一部分仍有一定价值的文章搬运过来。</p>
<p>同时在技术之外，这个网站也会收录一些个人在平常的所感所想，无意义的念叨，以及生活的碎片。我想，人总归还是希望能留下些什么东西。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>Docker基础原理探究</title>
    <url>/2025/08/29/old-docker-principle/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2021年11月27日。</strong></p>
<h2 id="一、前言-Docker是什么？"><a href="#一、前言-Docker是什么？" class="headerlink" title="一、前言 Docker是什么？"></a>一、前言 Docker是什么？</h2><blockquote>
<p>Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development - desktop and cloud. Docker’s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.</p>
</blockquote>
<p>Docker是一个用Go编写的开源工具，它可以将你的应用打包成一个标准格式的镜像，并且以容器的方式运行。Docker容器将一系列软件包装在一个完整的<strong>文件系统</strong>中，这个文件系统包含应用程序运行所需要的一切：代码、运行时工具、系统工具、系统依赖，几乎有任何可以安装在服务器上的东西。这些策略保证了容器内应用程序运行环境的稳定性，不会被容器外的系统环境所影响。</p>
<p><img src="https://i.loli.net/2021/11/16/FUWQXIS5ZNdvA7Y.jpg" alt="R-C.jpeg"></p>
<h3 id="Docker容器的特点："><a href="#Docker容器的特点：" class="headerlink" title="Docker容器的特点："></a>Docker容器的特点：</h3><ol>
<li>轻量： 在同一台宿主机上的容器将共享系统kernel，使得它们可以迅速启动而且占用较少的内存。镜像是以<strong>分层文件系统</strong>构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度都得到较大提高。</li>
<li>开放： Docker容器基于开放标准，使得其可以运行在各种主流Linux Distribution和Windows，以及Mac OS上。</li>
<li>安全： 容器将各个运行的应用程序相互隔离开来，给所有的应用程序提供了一层额外的安全防护。</li>
</ol>
<h3 id="容器和虚拟机相比"><a href="#容器和虚拟机相比" class="headerlink" title="容器和虚拟机相比"></a>容器和虚拟机相比</h3><p>容器和虚拟机同样具有资源隔离和分配的功能，但由于其架构的不同，容器比虚拟机更加便捷和高效。<br>首先是犯下傲慢之罪的虚拟机，包含用户的程序，必要的函数库和整个客户操作系统，至少也需要占用好几个GB的空间。如图所示，除了使用Hypervisor技术对硬件设施进行虚拟化外，虚拟机还多一层guest OS。<br>而docker容器则是在docker engine的控制和驱动下，以用户态运行，并在宿主机上互相隔离。docker直接使用硬件资源和共享内核，不和任何基础设施绑定。</p>
<p><img src="https://i.loli.net/2021/11/16/yYOHjz3NRrJPZVp.png" alt="20006deca0fccda0d536edd626835e9e_720w.png"></p>
<h3 id="容器基本概念"><a href="#容器基本概念" class="headerlink" title="容器基本概念"></a>容器基本概念</h3><p>我们还是先回顾一波docker中的基础概念。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">镜像（Image）</td>
<td>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 centos8 就包含了完整的一套 CentOS 8 最小系统的 root 文件系统。</td>
</tr>
<tr>
<td align="center">容器（Container）</td>
<td>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</td>
</tr>
<tr>
<td align="center">仓库（Repository）</td>
<td>仓库可看成一个代码控制中心，用来保存镜像。</td>
</tr>
<tr>
<td align="center">Docker 客户端(Client）</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="center">Docker 主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="center">Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</td>
</tr>
</tbody></table>
<h2 id="二、docker的基本使用"><a href="#二、docker的基本使用" class="headerlink" title="二、docker的基本使用"></a>二、docker的基本使用</h2><p>以一个精简的UNIX工具箱busybox为例</p>
<p><code>docker pull busybox</code><br>从仓库拉取latest的busybox镜像</p>
<p><code>docker images</code><br>查看本地镜像</p>
<p><code>docker rmi  -f busybox</code><br>强制删除busybox镜像</p>
<p><code>docker run -it ubuntu /bin/bash</code><br>从镜像生成一个容器，分配伪终端，并采用交互模式运行，且在进入容器后执行&#x2F;bin&#x2F;bash</p>
<p><code>docker ps</code><br>查看所有正在运行的容器，加参数-a还可以查看停运的容器</p>
<p><code>docker start busybox</code><br>启动停止运行的容器busybox</p>
<p><code>docker stop busybox</code><br>停止正在运行的容器busybox</p>
<p><code>docker restart busybox</code><br>重启容器busybox</p>
<p><code>docker kill busybox</code><br>杀死运行中的容器busybox</p>
<p><code>docker rm -f busybox</code><br>移除容器busybox</p>
<p><code>docker pause busybox</code><br>暂停容器中所有进程</p>
<p><code>docker unpause busybox</code><br>暂停后继续容器中所有进程</p>
<p><code>docker create busybox</code><br>创建一个容器但是不启动</p>
<p><code>docker exec -it busybox /bin/bash</code><br>在正在运行的容器中执行&#x2F;bin&#x2F;bash这个命令<br>这也是进入运行中容器的一种方法</p>
<p>and so on……</p>
<h2 id="二、Docker实现原理探究"><a href="#二、Docker实现原理探究" class="headerlink" title="二、Docker实现原理探究"></a>二、Docker实现原理探究</h2><p>那么，docker是如何生成这样精简而健全的一个个容器的呢？今天，我们就来研究一波其中运用到的三个主要的功能：<strong>Linux namespace, cgroups, Union File System(UFS)</strong>。下面我们一一进行探讨。</p>
<h3 id="Linux-namespace"><a href="#Linux-namespace" class="headerlink" title="Linux namespace"></a>Linux namespace</h3><p>本来，不同的进程是共享同一份内核资源的。要做一个通俗的类比的话，如果说每个进程是单独的一个住户，那么内核资源就好比是小区里的公共场所，大家都可以使用，且使用情况对彼此都可见。而ns的作用，就是把这样的公共场所隔离开来。但这里的<strong>隔离</strong>，说的并不是将公共场所分成几部分，交给不同的进程，而是每个进程依然有原来一样大的公共场所，公共场所中的资源和变更情况只有他自己能看到。如果他在公共场所丢了一根烟头，则只有他自己知道，其他人（进程）是感知不到的。<br>Linux Namespace就是这样提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的Namespace中，来实现资源隔离的目的。不同Namespace的程序，可以享有一份独立的系统资源。<br><img src="https://i.loli.net/2021/11/16/dHxQRgG9uBOZDTr.jpg" alt="OIP-C.jpeg"><br>namespace的API有如下3个syscall:</p>
<ul>
<li>clone() 创建新进程，并根据传入的系统调用参数判断那些类型的namespace被创建，并且其子进程也会包含到这些namespace中。</li>
<li>unshare() 将进程移出某个namespace。</li>
<li>setns() 将进程加入某个namespace。</li>
</ul>
<p>目前Linux中提供了六类系统资源的隔离机制，分别是：</p>
<ul>
<li>Mount: 隔离文件系统挂载点</li>
<li>UTS: 隔离主机名和域名信息</li>
<li>IPC: 隔离进程间通信</li>
<li>PID: 隔离进程的ID</li>
<li>Network: 隔离网络资源</li>
<li>User: 隔离用户和用户组的ID</li>
<li>Cgroup: 隔离cgroup根目录（最新，尚未被docker采用）<br>下面一一解释他们的作用：</li>
</ul>
<h4 id="Mount-namespace"><a href="#Mount-namespace" class="headerlink" title="Mount namespace"></a>Mount namespace</h4><p>Mount Namespace用来<em>隔离各个进程看到的挂载点视图</em>。不同namespace的进程，看到的文件系统层次是不同的。在mount namespace中调用mount, umount等命令只会影响当前namespace内的文件系统，而对全局的文件系统是没有影响的。（事实上，docker容器内的挂载情况确实和宿主机不同。）<br>Mount Namespace是linux第一个实现的namespace类型，因而它的syscall参数比较特殊，是NEWNS。<br><img src="https://i.loli.net/2021/11/16/amiSFvLeyJ6k5A7.png" alt="ns-mount.png"><br>但是有一点需要注意：有些时候，Mount Namespace其实并不能真正隔离挂载信息！这是因为linux中还存在一种名为<strong>Shared Subtree</strong>的机制！<br>引入该机制是为了消除mount ns带来的不便，比如系统新增一块磁盘，我希望所有的NS都感知到新挂载的这块磁盘，那么如果NS 之间是完全隔离的，就需要每个都执行一次挂载操作，这是非常不变的，shared subtree保证了不同的NS 之间可以共享挂载信息。<br>共享子树有两大核心：<strong>peer group</strong>和<strong>propagate type</strong>。</p>
<ul>
<li>peer group<br>表示了一个或多个挂载点的集合，下面两种情况属于统一group：</li>
</ul>
<p>通过–bind操作挂载的源挂载点和目标挂载点（前提是源目录是个挂载点）<br>生成新mount ns时，复制过去的挂载点之间同在一个group</p>
<ul>
<li>propagate type(传播属性)<br>这是mount点的属性，其常见值有：</li>
</ul>
<ol>
<li>MS_SHARED  该挂载点的删除操作、该挂载点下子挂载点的新增和删除操作都会同步到同一group中的其他mount点，且其他同group的mount点的操作也会同步到该mount点</li>
<li>MS_PRIVATE  与1相反，不会将自己的信息共享出去，也不接受其他点的共享，从而实现真正的隔离</li>
<li>MS_SLAVE  单向的共享，自己的更新不会影响到他人，但是他人的操作会同步到自己</li>
</ol>
<p>通过以下命令当前挂载点的传播属性：<br><code>cat /proc/self/mountinfo </code><br>可以发现所有进程默认情况下都是shared的。又因为通过系统调用clone出的namespace与父进程处在一个peer group下，所以会完全copy父进程的挂载点信息，因此子进程的挂载点也是shared。如果不注意到这点的话，创建的容器就不会真正隔绝挂载信息，且会引起一些不妙的后果。我们放在后面构建简单docker容器的实战中再说这个bug。</p>
<h4 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h4><p>UTS namespace主要用来<em>nodename和domainname</em>两个系统标识。也就是说，每个UTS Namespace被允许有自己的主机名（docker网络通信的重要基础之一）。<br>我们可以通过一个简单的Go语言demo来验证UTS namespace的作用：</p>
<pre><code>func main() &#123;
    cmd := exec.Command(&quot;sh&quot;)//指定新进程的初始命令
    cmd.SysProcAttr = &amp;syscall.SysProcAttr &#123;
        CloneFlags: syscall.CLONE_NEWUTS,
    &#125;//设定系统调用属性
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr//设置标准输入输出

    if err := cmd.Run(); err != nil &#123;
        log.Fatal(err)
    &#125;//运行命令和错误处理
&#125;
</code></pre>
<p>执行代码，在启动的交互式环境里，先用echo $$输出一下当前进程的PID，再用pstree -pl查看进程树，找到父进程。由于在进程目录下的ns目录包含进程的namespace信息，其中uts就对应 UTS namespace的信息。且由于ns目录下的这些文件其实都是特殊的符号链接，所以需要用readlink读取其实际指向的内容，便可以知道其UTS namespace的inode号了。于是用readlink &#x2F;proc&#x2F;xxxxx&#x2F;ns&#x2F;uts比较ns的inode，可以验证他们不在同一个UTS Namespace中。<br>接着，执行hostname -b chenpeng，修改当前主机名。另外启动一个shell，使用hostname命令，会发现外部的hostname并未因内部的修改而改变，证明了UTS Namespace的作用。<br>其他namespace的作用可以类似地验证，接下来就主要介绍他们的作用即可。</p>
<h4 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h4><p>用来隔离System V IPC和POSIX message queues。</p>
<h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h4><p>用来隔离进程ID。同样一个进程在不同的PID Namespace中可以拥有不同的PID。可以通过分别在宿主机和容器内执行ps -ef验证docker对这个namespace的运用。</p>
<h4 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h4><p>用来隔离用户的用户组ID。也就是说，一个进程的User ID和Group ID在User Namespace内外可以是不同的。比如在宿主机上的以非root用户运行创建一个User Namespace，而在namespace里面这个用户被映射为root用户。这意味着，这个进程在User Namespace里拥有root权限，但在外面却没有。从Linux Kernel 3.8开始，非root进程也可以创建User Namespace并被映射成root。</p>
<h4 id="Netwoek-Namespace"><a href="#Netwoek-Namespace" class="headerlink" title="Netwoek Namespace"></a>Netwoek Namespace</h4><p>用来隔离网络设备、IP地址端口等网络栈。可以让每个容器拥有自己独立的虚拟网络设备，且容器内的应用可以绑定到自己的端口，使得各个Namespace内的端口不会互相冲突。且在宿主机上搭建网桥后，可以很方便地实现容器间通信。此外，通过端口映射，可以使得不同容器上的应用使用相同的端口号。</p>
<h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>namespace技术可以帮助构建出的容器拥有自己与外部隔离的单独的空间，但Docker是如何限制每个容器所占空间的大小，从而保证它们不会相互争抢的呢？这就要运用Cgroups技术。<br>Linux Cgroups（Control Groups）提供了对一组进程及其将来子进程的资源限制、控制和统计的能力，这些资源包括CPU,内存，存储，网络等。通过Cgroups，可以方便地限制某个进程的资源占用，并且实时地监控进程和统计信息。<br>比如可以通过cgroup限制特定进程使用特定数目的cpu核数和特定大小的内存，如果资源超限的情况下，会被暂停或者杀掉。</p>
<ul>
<li>任务(task): 在cgroups中，task就是一个进程或线程。</li>
<li>控制组(control group): cgroups的资源控制是以cgroup的方式实现，cgroup指明了资源的配额限制。进程可以加入到某个cgroup，也可以迁移到另一个cgroup。</li>
<li>层级(hierarchy): cgroup有层级关系，类似树的结构，子节点的cgroup继承父cgroup的属性(资源配额、限制等)。</li>
<li>子系统(subsystem): 一个subsystem其实就是一种资源的控制器，比如memory subsystem可以控制进程内存的使用。subsystem需要加入到某个hierarchy，然后该hierarchy的所有cgroup，均受到这个subsystem的控制。<br>subsystem的类别：<ul>
<li>cpu: 限制进程的 cpu 使用率。</li>
<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li>cpuset: 为cgroups中的进程分配单独的cpu节点或者内存节点。</li>
<li>memory: 限制进程的memory使用量。</li>
<li>blkio: 限制进程的块设备io。</li>
<li>devices: 控制进程能够访问某些设备。</li>
<li>net_cls: 标记cgroups中进程的网络数据包，然后可以使用tc模块（traffic control）对数据包进行控制。</li>
<li>net_prio: 限制进程网络流量的优先级。</li>
<li>huge_tlb: 限制HugeTLB的使用。</li>
<li>freezer:挂起或者恢复cgroups中的进程。</li>
<li>ns: 控制cgroups中的进程使用不同的namespace。</li>
</ul>
</li>
</ul>
<p>也就是说，cgroup是管理一组task的基本单元，其作为结点组成的树结构叫做hiierarchy。subsystem附加在hierarchy上，对其中的cgroup进行资源限制，同时子结点继承父结点的配置。<br><img src="https://i.loli.net/2021/11/16/nXhgHSrBY5IZ9oq.png" alt="cgroup.png"><br>三个组件的关系：系统创建新的hierarchy后，系统中的所有进程都会加入这个hierarchy的cgroup根节点，这个根节点是由hierarchy默认创建的。一个subsystem只能附加到一个hierarchy上面，一个hierarchy可以附加多个subsystem，一个进程可以作为多个cgroup的成员，但这些cgroup必须在不同的hierarchy中；一个进程fork出子进程时，父子同属于一个cgroup，但也可以根据需要移到不同的cgroup中。<br>如何调用内核才能配置Cgroups呢？前面提到，hierarchy是一种树状的组织结构，kernel为了使对Cgroups的配置更加直观，是通过一个虚拟的树状文件系统来配置Cgroup的，也就是通过层级的目录来虚拟出一棵hierarchy(cgroup tree)。示例：</p>
<pre><code>mkdir cgroup-test
sudo mount -t cgroup -o none, name=cgroup-test cgroup-test ./cgroup-test
ls ./cgroup-test
</code></pre>
<p>以上在当前目录创建一个文件夹，并挂载了一个cgroup类型的文件系统，这样就创建了一棵hierarchy。ls查看一下目录，会发现生成了一些默认的文件：</p>
<ul>
<li><p>cgroup.clone_children cpuset的subsystem会读取这个配置文件,如果这个值(默认值是0)是 1 子cgroup才会继承父cgroup的cpuset的配置</p>
</li>
<li><p>cgroup.procs是树中当前节点cgroup中的进程组ID,现在的位置是根节点,这个文件中会有现在系统中所有进程组的ID</p>
</li>
<li><p>notify_on_release和release_agent 会一起使用。notify_on_release 标志当这个cgroup最后一个进程退出的时候是否执行了release_agent</p>
</li>
<li><p>release_agent 则是一个路径,通常用作进程退出后自动清理不再使用的cgroup</p>
</li>
<li><p>task 标识该cgroup下面进程ID,如果把一个进程ID写到task文件中,便会把相应的进程加入到这个cgroup中。<br>在该目录下继续创建文件夹，就是扩展子cgroup，其也会自动创建一些文件配置项。<br>但是由于我们创建的这个hierarchy没有附加任何subsystem（-o 后的值为none），所以没办法对其中的cgroup限制进程资源占用。值得一提的是，各种subsystem在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;下有系统已经创建好的默认的hierarchy，因而很方便我们使用。(或者也可以使用-o memory)<br>在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory下：</p>
<p>  sudo mkdir test &amp;&amp; cd test<br>  sudo sh -c “echo “100m” &gt; memory.limit_in_bytes”<br>  sudo sh -c “echo $$ &gt; tasks”<br>  stress –vm-bytes 200m –vm-keep -m 1</p>
</li>
</ul>
<p>以上，我们在挂载了memory子系统的hierarchy下创建了一个cgroup，并通过修改配置项对其内存资源限制（200m以下），然后使用stress进行压力测试。<br>使用top等命令可以发现，其内存确实被限制，验证了cgroups的限制资源的能力。<br>在Docker中，我们可以在启动一个容器的时候传入参数-m 100m达到这种效果，即将容器的内存占用限制在100m，这背后就是由cgroups技术实现的。Dokcer通过为每个容器创建cgroup,配置资源限制和监控。</p>
<h3 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h3><p>Union FS，是一种为linux,fressBSD,netBSD操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录透明地覆盖，形成一个单一的文件系统。这些branch或者是ro的，或者是rw的，所以当对这个虚拟后的联合文件系统进行写操作时，系统是真正写到了一个新文件中。看起来这个虚拟后的联合文件系统可以对任何文件进行操作，但其实并没有改变原来的文件，这是因为unionfs使用了一个重要的资源管理技术——<strong>写时复制</strong>(copy-on-write)。<br>coW，也叫做隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时不需要立即创建一个新的资源，这个资源可以被新旧实例共享。创建新资源只会发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著减少未修改资源的复制所带来的消耗。</p>
<h4 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h4><p>AUFS，全称是Advanced Multi-Layerd Unification Filesystem，完全重写了早期的UnionFS 1.x，并引入了一些新的功能，比如可写分支的负载均衡。<br>AUFS是docker选用的第一种存储驱动，具有快速启动容器、高效利用存储和内存等优点，直到现在依然被docker支持。接下来，介绍docker是如何利用AUFS存储镜像和容器的。<br>我们知道，在docker中，每一个image都是由一系列read-only layer组成的。image layer的内容都存储在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff目录下。而&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;layers目录则存储image layer如何堆栈这些layer的metadata。</p>
<p><img src="https://i.loli.net/2021/11/16/xpBINYUX5t6Mzlc.jpg" alt="container-layers.jpg"></p>
<h4 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h4><p>Overlay2是现版本Docker默认使用的存储驱动，通常情况下，overlay2 会比AUFS性能更好，而且更加稳定，但是二者基本的存储思路都是分层。overlay2 和 AUFS 类似，它将所有目录称之为层（layer），overlay2 的目录是镜像和容器分层的基础，而把这些层统一展现到同一的目录下的过程称为联合挂载（union mount）。overlay2 把目录的下一层叫作lowerdir，上一层叫作upperdir，联合挂载后的结果叫作merged。<br>总体来说，overlay2 是这样储存文件的：overlay2将镜像层和容器层都放在单独的目录，并且有唯一 ID，每一层仅存储发生变化的文件，最终使用联合挂载技术将容器层和镜像层的所有文件统一挂载到容器中，使得容器中看到完整的系统文件。</p>
<p>接下来以overlay2为例，探究docker是如何存放镜像的。<br>首先从仓库拉取一个ubuntu16.04镜像，然后查看该镜像的信息：</p>
<p><code>docker pull ubuntu:16.04</code><br>观察到如下信息：</p>
<pre><code>16.04: Pulling from library/ubuntu
58690f9b18fc: Pull complete 
b51569e7c507: Pull complete 
da8ef40b9eca: Pull complete 
fb15d46c38dc: Pull complete 
Digest: sha256:0f71fa8d4d2d4292c3c617fda2b36f6dabe5c8b6e34c3dc5b0d17d4e704bd39c
Status: Downloaded newer image for ubuntu:16.04
</code></pre>
<p>可以看到，镜像正是被分为4层拉取下来的。在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2可以找到所有拉取下来的layer。此外，该目录下还有一个l目录，这里全是到各层diff之间的软链接，把一些较短的随机串软连到镜像层的 diff 文件夹下，这样做是为了避免达到mount命令参数的长度限制。<br>先随意查看一个镜像层的内容：diff,link,lower,work。<br>在这里，link 文件内容为该镜像层对应l目录中的短 ID，diff 文件夹为该镜像层的改动内容，也是被联合挂载的内容，lower 文件为该层的所有父层镜像的短 ID，规定了镜像间的层序关系。<br>我们可以用docker inspect来找到某个镜像的层级之间的关系：</p>
<pre><code>docker image inspect ubuntu
...
&quot;GraphDriver&quot;: &#123;
            &quot;Data&quot;: &#123;
                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/ca36b188418e7d85232c6d90144380e543ec45fb4cc962bf2f45d4a823c0f9cd/diff:/var/lib/docker/overlay2/4f934d2bbd300caf92c0f00c85201053c20881c91810f32c5bef850581990acd/diff:/var/lib/docker/overlay2/579a385ff86c563d0c4c71bcc5471133b674d102de7ab38555e66ec955f5dcdb/diff&quot;,
                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/merged&quot;,
                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/diff&quot;,
                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/work&quot;
            &#125;,
            &quot;Name&quot;: &quot;overlay2&quot;
        &#125;,
...
</code></pre>
<p>其中 MergedDir 代表当前镜像层在 overlay2 存储下的目录，LowerDir 代表当前镜像的父层关系，使用冒号分隔，冒号最后代表该镜像的最底层。<br>接着启动容器，再用docker inspect查看容器的层级关系：</p>
<pre><code>docker inspect ubuntu
...
&quot;GraphDriver&quot;: &#123;
        &quot;Data&quot;: &#123;
            &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d-init/diff:/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/diff:/var/lib/docker/overlay2/ca36b188418e7d85232c6d90144380e543ec45fb4cc962bf2f45d4a823c0f9cd/diff:/var/lib/docker/overlay2/4f934d2bbd300caf92c0f00c85201053c20881c91810f32c5bef850581990acd/diff:/var/lib/docker/overlay2/579a385ff86c563d0c4c71bcc5471133b674d102de7ab38555e66ec955f5dcdb/diff&quot;,
            &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/merged&quot;,
            &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/diff&quot;,
            &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/work&quot;
        &#125;,
        &quot;Name&quot;: &quot;overlay2&quot;
    &#125;,
...
</code></pre>
<p>这里MergedDir 的内容即为容器层的工作目录，LowerDir 为容器所依赖的镜像层目录。实际上，overlay2将lowerdir、upperdir、workdir联合挂载，形成最终的merged挂载点，其中lowerdir是镜像只读层，upperdir是容器可读可写层，workdir是执行涉及修改lowerdir执行copy_up操作的中转层（例如，upperdir中不存在，需要从lowerdir中进行复制，该过程暂未详细了解，遇到了再分析）。</p>
<h3 id="实战：自制简单docker"><a href="#实战：自制简单docker" class="headerlink" title="实战：自制简单docker"></a>实战：自制简单docker</h3><p>明白了以上三个基本原理，实际上我们已经可以制作一个简单的小docker了！这里为了方便，还是使用AUFS作为存储。<br>首先，使用go的urfave&#x2F;cli命令行工具，将代码改造成命令行程序：</p>
<pre><code>const usage = `we make a small docker container by ourselves using basic knowledge.`

func main() &#123;
    app := cli.NewApp()
    app.Name = &quot;mydocker&quot;
    app.Usage = usage

    app.Commands = []cli.Command&#123;
        initCommand,
        runCommand,
    &#125;

    app.Before = func(context *cli.Context) error &#123;
        // Log as JSON instead of the default ASCII formatter.
        log.SetFormatter(&amp;log.JSONFormatter&#123;&#125;)

        log.SetOutput(os.Stdout)
        return nil
    &#125;

    if err := app.Run(os.Args); err != nil &#123;
        log.Fatal(err)
    &#125;
&#125;
</code></pre>
<p>这里我们规定了2条命令：run和init，其中run就和docker run一样是启动容器，而init是内部调用的用于初始化容器的命令。接着，我们详细定义这两条命令：</p>
<pre><code>var runCommand = cli.Command&#123;
    Name: &quot;run&quot;,
    Usage: `Create a container with namespace and cgroups limit
            mydocker run -ti [command]`,
    Flags: []cli.Flag&#123;
        cli.BoolFlag&#123;
            Name:  &quot;ti&quot;,
            Usage: &quot;enable tty&quot;,
        &#125;,
    &#125;,
    Action: func(context *cli.Context) error &#123;
        if len(context.Args()) &lt; 1 &#123;
            return fmt.Errorf(&quot;Missing container command&quot;)
        &#125;
        var cmdArray []string
        for _, arg := range context.Args() &#123;
            cmdArray = append(cmdArray, arg)
        &#125;
        tty := context.Bool(&quot;ti&quot;)
        Run(tty, cmdArray)
        return nil
    &#125;,
&#125;

var initCommand = cli.Command&#123;
    Name:  &quot;init&quot;,
    Usage: &quot;Init container process run user&#39;s process in container. Do not call it outside&quot;,
    Action: func(context *cli.Context) error &#123;
        log.Infof(&quot;init come on&quot;)
        err := container.RunContainerInitProcess()
        return err
    &#125;,
&#125;
</code></pre>
<p>其中flags规定了一些调用参数，如ti就和docker中一样，意义是启动终端和交互。action是命令真正的入口，这里先判断有无命令，再读取args将命令存入cmdArray。最后调用了Run函数：</p>
<pre><code>func Run(tty bool, comArray []string) &#123;
    parent, writePipe := container.NewParentProcess(tty)
    if parent == nil &#123;
        log.Errorf(&quot;New parent process error&quot;)
        return
    &#125;
    if err := parent.Start(); err != nil &#123;
        log.Error(err)
    &#125;
    sendInitCommand(comArray, writePipe)
    parent.Wait()
    mntURL := &quot;/cproot/mnt/&quot;
    rootURL := &quot;/cproot/&quot;
    container.DeleteWorkSpace(rootURL, mntURL)
    os.Exit(0)
&#125;

func sendInitCommand(comArray []string, writePipe *os.File) &#123;
    command := strings.Join(comArray, &quot; &quot;)
    log.Infof(&quot;command all is %s&quot;, command)
    writePipe.WriteString(command)
    writePipe.Close()
&#125;
</code></pre>
<p>接着，首先调用了NewParentProcess函数，如下：</p>
<pre><code>func NewParentProcess(tty bool) (*exec.Cmd, *os.File) &#123;
    readPipe, writePipe, err := NewPipe()
    if err != nil &#123;
        log.Errorf(&quot;New pipe error %v&quot;, err)
        return nil, nil
    &#125;
    cmd := exec.Command(&quot;/proc/self/exe&quot;, &quot;init&quot;)
    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;
        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |
            syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,
    &#125;
    if tty &#123;
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
    &#125;
    cmd.ExtraFiles = []*os.File&#123;readPipe&#125;
    mntURL := &quot;/cproot/mnt/&quot;
    rootURL := &quot;/cproot/&quot;
    NewWorkSpace(rootURL, mntURL)
    cmd.Dir = mntURL
    return cmd, writePipe
&#125;

func NewPipe() (*os.File, *os.File, error) &#123;
    read, write, err := os.Pipe()
    if err != nil &#123;
        return nil, nil, err
    &#125;
    return read, write, nil
&#125;
</code></pre>
<p>这里先调用NewPipe创建了用于外部和容器通信的管道，接着设置了需要执行的两条命令：<br>&#x2F;proc&#x2F;self&#x2F;exe 当前正在运行的进程本身的可执行文件，这就是自己调用自己，来初始化刚创建出的进程。<br>init 就是刚刚自定义的命令。<br>接着设置了系统调用属性：这里就是fork出一个新进程，且为这个进程设置了若干namespace，来与外部环境进行隔离。<br>由于进程的3个文件描述符已经被标准输入、输出、错误所占用，所以就通过extraFiles传入了管道读取端给子进程。接着规定了，联合文件系统最终的挂载目录和镜像、容器layer所在的目录。紧接着便调用了NewWorkSpace函数：</p>
<pre><code>func NewWorkSpace(rootURL string, mntURL string) &#123;
    CreateReadOnlyLayer(rootURL)
    CreateWriteLayer(rootURL)
    CreateMountPoint(rootURL, mntURL)
&#125;

func CreateReadOnlyLayer(rootURL string) &#123;
    busyboxURL := rootURL + &quot;busybox/&quot;
    busyboxTarURL := rootURL + &quot;busybox.tar&quot;
    exist, err := PathExists(busyboxURL)
    if err != nil &#123;
        log.Infof(&quot;Fail to judge whether dir %s exists. %v&quot;, busyboxURL, err)
    &#125;
    if exist == false &#123;
        if err := os.Mkdir(busyboxURL, 0777); err != nil &#123;
            log.Errorf(&quot;Mkdir dir %s error. %v&quot;, busyboxURL, err)
        &#125;
        if _, err := exec.Command(&quot;tar&quot;, &quot;-xvf&quot;, busyboxTarURL, &quot;-C&quot;, busyboxURL).CombinedOutput(); err != nil &#123;
            log.Errorf(&quot;Untar dir %s error %v&quot;, busyboxURL, err)
        &#125;
    &#125;
&#125;

func CreateWriteLayer(rootURL string) &#123;
    writeURL := rootURL + &quot;writeLayer/&quot;
    if err := os.Mkdir(writeURL, 0777); err != nil &#123;
        log.Errorf(&quot;Mkdir dir %s error. %v&quot;, writeURL, err)
    &#125;
&#125;

func CreateMountPoint(rootURL string, mntURL string) &#123;
    if err := os.Mkdir(mntURL, 0777); err != nil &#123;
        log.Errorf(&quot;Mkdir dir %s error. %v&quot;, mntURL, err)
    &#125;
    dirs := &quot;dirs=&quot; + rootURL + &quot;writeLayer:&quot; + rootURL + &quot;busybox&quot;
    cmd := exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, mntURL)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil &#123;
        log.Errorf(&quot;%v&quot;, err)
    &#125;
&#125;
</code></pre>
<p>这个函数分为3个部分，首先是创建镜像层（只读），接着是创建容器可写层，最后就是用AUFS的方式将容器层、可写层联合挂载到指定的mntURL下。<br>通过调用newparentprocess，我们就从返回值得到了这样的一条命令，并在Run函数中对其调用start函数，这才是真正开始这条命令的执行，它会首先clone出一个namespace隔离的进程，并在子进程中先调用&#x2F;proc&#x2F;self&#x2F;exe，即其本身，接着调用我们写的init方法，进行初始化。然后便开始执行sendInitCommand函数，即将用户输入的命令读取到管道的写入端。当程序执行完毕后，会调用wait释放进程资源并退出，以及执行DeleteWorkSpace删除可写层和解挂aufs系统（相当于退出容器），这些都是后话。<br>生成子进程后，首先会调用自己，即启动子进程。接着子进程就会执行init命令，调用RunContainerInitProcess()。也就是说，调用这个函数时，我们已经身处namespace内的子进程了：</p>
<pre><code>func RunContainerInitProcess() error &#123;
    cmdArray := readUserCommand()
    if cmdArray == nil || len(cmdArray) == 0 &#123;
        return fmt.Errorf(&quot;Run container get user command error, cmdArray is nil&quot;)
    &#125;

    setUpMount()

    path, err := exec.LookPath(cmdArray[0])
    if err != nil &#123;
        log.Errorf(&quot;Exec loop path error %v&quot;, err)
        return err
    &#125;
    log.Infof(&quot;Find path %s&quot;, path)
    if err := syscall.Exec(path, cmdArray[0:], os.Environ()); err != nil &#123;
        log.Errorf(err.Error())
    &#125;
    return nil
&#125;

func readUserCommand() []string &#123;
    pipe := os.NewFile(uintptr(3), &quot;pipe&quot;)
    msg, err := ioutil.ReadAll(pipe)
    if err != nil &#123;
        log.Errorf(&quot;init read pipe error %v&quot;, err)
        return nil
    &#125;
    msgStr := string(msg)
    return strings.Split(msgStr, &quot; &quot;)
&#125;

/**
Init 挂载点
*/
func setUpMount() &#123;
    pwd, err := os.Getwd()
    if err != nil &#123;
        log.Errorf(&quot;Get current location error %v&quot;, err)
        return
    &#125;
    log.Infof(&quot;Current location is %s&quot;, pwd)
    pivotRoot(pwd)

    //mount proc
    defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
    quarantineMountFlags := syscall.MS_PRIVATE | syscall.MS_REC
    syscall.Mount(&quot;&quot;,&quot;/&quot;,&quot;&quot;, uintptr(quarantineMountFlags), &quot;&quot;)
    syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)

    //syscall.Mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, syscall.MS_NOSUID|syscall.MS_STRICTATIME, &quot;mode=755&quot;)
&#125;

func pivotRoot(root string) error &#123;
    /**
    为了使当前root的老 root 和新 root 不在同一个文件系统下，我们把root重新mount了一次
    bind mount是把相同的内容换了一个挂载点的挂载方法
    */
    log.Infof(&quot;pivotroot: root is %s&quot;, root)
    if err := syscall.Mount(root, root, &quot;bind&quot;, syscall.MS_BIND|syscall.MS_REC, &quot;&quot;); err != nil &#123;
        return fmt.Errorf(&quot;Mount rootfs to itself error: %v&quot;, err)
    &#125;
    // 创建 rootfs/.pivot_root 存储 old_root
    pivotDir := filepath.Join(root, &quot;.pivot_root&quot;)
    if err := os.Mkdir(pivotDir, 0777); err != nil &#123;
        return err
    &#125;
    // pivot_root 到新的rootfs, 现在老的 old_root 是挂载在rootfs/.pivot_root
    // 挂载点现在依然可以在mount命令中看到
    if err := syscall.PivotRoot(root, pivotDir); err != nil &#123;
        return fmt.Errorf(&quot;pivot_root %v&quot;, err)
    &#125;
    // 修改当前的工作目录到根目录
    if err := syscall.Chdir(&quot;/&quot;); err != nil &#123;
        return fmt.Errorf(&quot;chdir / %v&quot;, err)
    &#125;

    pivotDir = filepath.Join(&quot;/&quot;, &quot;.pivot_root&quot;)
    // umount rootfs/.pivot_root
    if err := syscall.Unmount(pivotDir, syscall.MNT_DETACH); err != nil &#123;
        return fmt.Errorf(&quot;unmount pivot_root dir %v&quot;, err)
    &#125;
    // 删除临时文件夹
    return os.Remove(pivotDir)
&#125;
</code></pre>
<p>首先是调用readCommand从管道读取用户传入的命令，并在后来识别系统环境变量并予以执行。接着调用setupMount开始一系列挂载工作。这里读取到的pwd就是指定的mntURL，也就是联合文件系统的挂载点，容器的工作目录。接着，调用pivotRoot(pwd)。众所周知，pivot_root是一个系统调用，主要功能是改变当前的rootfs。pivot_root可以将当前进程的rootfs移动到put_old文件夹，再使new_root成为新的rootfs。new_root和put_old必须不能同时存在当前root的同一个文件系统中。这个系统调用和chroot命令区别在于，前者是将整个系统切换到一个新的root目录，并移除对之前root文件系统的依赖，这样就能umount原先的rootfs。而后者只是针对某个进程，系统的其他部分依旧运行于老的root目录中。<br>注意！在挂载开始前，我们首先有这样的操作：</p>
<pre><code>quarantineMountFlags := syscall.MS_PRIVATE | syscall.MS_REC
syscall.Mount(&quot;&quot;,&quot;/&quot;,&quot;&quot;, uintptr(quarantineMountFlags), &quot;&quot;)
</code></pre>
<p>这就是开始将mount namespace时提出的，其作用相当于mount –make-rprivate &#x2F;,即递归修改整个mount树的propagate type为private，这样我们在容器内的挂载操作才不会传给外部。否则在接下来挂载proc后，回到主机系统，会发现很多命令都无法使用了。这其实就是因为主机的proc被修改了，需要在主机重新mount一次proc才能恢复正常。<br>这之后，init命令的工作也就做完了，此时我们的容器已启动起来。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>namespace</tag>
        <tag>Cgroups</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler 消息处理机制解析</title>
    <url>/2025/08/29/old-handler-src-analysis/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2021年9月11日。</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提到Android中的消息机制，想必大家对其都不陌生。Android消息机制，一般指handler和其附加的mq及looper的运行机制与工作过程。handler常用于解决在子线程不能访问UI的问题，举一个常见的例子：我们在子线程中执行了耗时工作后，需要对UI进行更新，但又不能直接在子线程更新UI（这是因为控件在重绘前会调用checkThread()检查当前是否为主线程，以防ANR）。此时我们就可以创建handler，并将要执行的代码逻辑写入一个runnable任务中，并调用handler的post(本质上仍是调用send)或send将任务提交给主线程的消息队列中，再由主线程的looper取出这个任务，在主线程执行，如此便自然地从子线程转入主线程，实现了UI的更新。当然我们也可以直接调用Activity类的runOnUiThread()方法，道理是一样的。下面就让我们一起从源码的角度探究handler消息处理机制的原理，以及handler使用存在的一些问题。</p>
<h1 id="handler的构造问题"><a href="#handler的构造问题" class="headerlink" title="handler的构造问题"></a>handler的构造问题</h1><p>handler有多个构造方法，我们常常用到的有以下几个：</p>
<ol>
<li>无参构造</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法已经弃用。其内部调用了另一个有参构造方法，但是传的值为null和false，让我们接下去看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先解释一下这个构造方法的参数：callback是handler中定义的一个接口，用于简化构建handler的过程（可以用实现这个接口来避免自定义handler子类），下文再对这个接口做详细解释。这里传入值为null，说明我们不采用这种方式。async标志这个handler是否采用异步消息，下文再对handler的异步、普通和屏障消息作区别以及介绍同步屏障机制。这里传入false，说明我们默认采用的都是普通消息机制。<br>这个构造方法首先会通过FIND_POTENTIAL_LEAKS判断是否由可能存在的内存泄漏情况，如果有，则会输出日志警告我们。（不过我没有找到设置这个bool值为true的代码部分。。。）关于handler潜在的内存泄漏风险，下文会重点讨论。接着调用Looper.myLooper()尝试获取当前线程的looper。我们进入这个方法看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了sThreadLocal的get方法并返回。那么sThreadLocal是什么呢？找到定义如下：</p>
<pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
</code></pre>
<p>发现这是一个ThreadLocal变量。关于ThreadLocal这里不做过多介绍（计划单独写一篇博客研究一下ThreadLocal，毕竟也是一个十分重要的知识点）。这样以来就明确了：每个线程只能有最多一个looper，并且存储在threadLocal里。调用get便可以得到当前线程的looper。但是除了主线程以外（主线程的消息机制下文会重点讨论），线程默认是没有looper的，需要自己通过prepare创建。如此，get方法就有可能返回null。当返回null时，就会抛出异常。以上我们可以得出一个结论：使用无参构造方法，必须确保当前线程持有looper，否则就会导致异常抛出。因此，这个方法被废弃也就不足为奇了。相应地，google建议我们使用另一个构造方法代替：<br>2. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(looper, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法同样在内部调用了另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里直接使用了参数指定的looper，并获得了其对应的消息队列。</p>
<h1 id="MQ的工作原理"><a href="#MQ的工作原理" class="headerlink" title="MQ的工作原理"></a>MQ的工作原理</h1><p>现在我们有了handler对象，并且这个handler内部持有某个线程的looper和messageQueue的对象。接着，就可以调用handler的send&#x2F;post方法发送消息了。由于查看源码可以知道post方法本质上还是将runnable包装成message后调用send系列方法，所以这里就直接看send系列方法。譬如调用sendMessage方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了另一个方法sendMessageDelayed。由此可见，我们也可以直接调用sendMessageDelayed并指定一个延迟时间，实现<strong>定时任务</strong>的效果。走进这个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又调用了另一个方法sendMessageAtTime。走进这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">可以看见，首先方法试图获取一个消息队列，如果获取不到则会发出警告并返回<span class="literal">false</span>，那么消息则发送失败，不了了之。否则，接下来会调用enqueueMessage方法，走进这个方法：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">        msg.target = <span class="built_in">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">直接看最后一行，发现经过一系列方法，最终调用的是消息队列的enqueueMessage方法，也是消息队列工作较为重要的一个方法。走进这个方法：</span><br><span class="line">```java</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> <span class="keyword">when</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                            msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">                    Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                    msg.recycle();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                msg.markInUse();</span><br><span class="line">                msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">                <span class="type">boolean</span> needWake;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> == <span class="number">0</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                    msg.next = p;</span><br><span class="line">                    mMessages = msg;</span><br><span class="line">                    needWake = mBlocked;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">                    <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                    <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                    needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                    Message prev;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        prev = p;</span><br><span class="line">                        p = p.next;</span><br><span class="line">                        <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                            needWake = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                    prev.next = msg;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">                <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                    nativeWake(mPtr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">```        </span><br><span class="line">虽然上面的代码比较长，但其实只做了一件很简单的事情：向消息队列插入当前消息。</span><br><span class="line">首先，我们要了解消息队列底层采用的数据结构。虽然称作队列，其本质上只是一个普通的单链表。这点可从message类的源码印证：</span><br><span class="line">```java</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="comment">/*package*/</span> Message next;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>每个message对象都有一个next指针域。<br>enqueueMessage首先会对一些特殊情况进行处理，接着上了synchronize保证对链表的访问是线程安全的。接着分两种情况：第一次插入，唤醒阻塞的队列并创建新头，插入第一条消息，否则就尾插到链表尾部。<br>那么，looper是如何取出mq中的消息的呢？这里就要调用另一个方法next()了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.<span class="keyword">when</span> - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.<span class="keyword">when</span>)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中涉及到许多值得注意的地方，比如同步屏障机制的实现等。但目前我们只关心next()方法的主要作用：取出消息队列中下一个消息。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"><span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronousmessage in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.<span class="keyword">when</span>) &#123;</span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.<span class="keyword">when</span> - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line"><span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取了当前系统时间now。接着开始遍历消息队列。如果遇到屏障，则跳过普通消息寻找下一个异步消息（暂且不管）。而如果遍历到的消息的when字段大于当前时间，说明这个消息还未准备好，于是不先取出而是设置了一个唤醒时间，等到时间时再取出。否则，取出当前消息，并返回给调用者（looper）。而如果迟迟没有返回，消息队列就会设置nextPollTimeoutMillis为-1，并无限循环地阻塞下去，直到取出并返回可用的消息。最后是消息队列退出时的一些善后操作。<br>如此以来，消息队列的工作原理我们就大致清晰了。</p>
<h1 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h1><p>handler负责发送和接收消息，message queue负责按FIFO方式存储消息，而looper则负责无限期地从mq中取出消息并分发给handler。looper的核心方法是loop()。<br>我们先了解一些looper类的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Observer sObserver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> mInLoop;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> Printer mLogging;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> mTraceTag;</span><br></pre></td></tr></table></figure>
<p>其中sThreadLocal我们已经不陌生了，用来保存不同线程的Looper对象；sMainLooper是主线程的looper，这个比较特殊。sObserver是用来处理事务的观察者（暂且不管）。mQueue用来保存消息队列，mThread是当前工作线程。mInLoop标记looper正在工作当中。mLogging是日志工具。</p>
<p>前面已经提到，每一个线程必须先构造looper，消息机制才能正常工作。那么我们就来看一看Looper的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里就是简单地构造了looper对应的消息队列，并保存了当前的线程对象。值得注意的是，这个唯一的构造方法是私有的，说明我们不能直接通过new获取一个looper。相反，我们需要调用prepare()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在prepare方法中，我们会先尝试从threadLocal中获取looper，看看当前线程是否已经有looper了。如果有，将会抛出异常，以此保证每个线程只能持有最多一个looper对象。如果没有，就会构造looper并放入threadLocal中。</p>
<p>前面我们反复提到了主线程looper的特殊性。实际上，Looper类还提供了一个prepareMainLooper()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        prepare(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">这个方法原本用于让ActivityThread创建主线程looper，但现在安卓环境会自己帮你创建，于是这个方法就被废弃了。现在，我们只需要知道主线程looper是系统自身已经创建好的，不需要自己再调用prepare方法创建。</span><br><span class="line">下面我们开始介绍loop()方法。只有调用了loop()，消息循环才能真正起作用。</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me.mInLoop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">                SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                        + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">slowDeliveryDetected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">            <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.<span class="keyword">when</span> &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.<span class="keyword">when</span>) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.<span class="keyword">when</span>, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```java</span><br><span class="line">提取出核心代码，其实loop的工作非常简单：</span><br><span class="line">```java</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(;;)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>就是无限循环地调用mq的next()方法，直到mq退出返回Null。什么时候mq返回null呢？当looper调用quit方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        mQueue.quit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">会接着调用mq的quit:</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">(<span class="type">boolean</span> safe)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">这里将消息队列的mQuitting设置为了<span class="literal">true</span>。再看next()中的一段代码：</span><br><span class="line">```java</span><br><span class="line">    <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，looper调用quit时，mq就会退出。消息循环终止。<br>现在，我们有了looper，当Looper从mq中取出了一条消息时，就会对其进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">```    </span><br><span class="line">其中，msg.target就是发送这条消息的对象。也就是说，当我们使用handler发送一条消息后，这条消息经过放入mq，再被looper取出，又被looper分发给了同一个handler。只不过handler对象虽然是同一个，发送和接收消息时所处的线程却不一定相同。下面我们一探handler的dispatchMessage()方法：</span><br><span class="line"></span><br><span class="line"># Handler的工作原理</span><br><span class="line">如何使用handler发送消息，已经在介绍MQ时说过了。我们主要看一看handler是如何处理Looper取出的消息的：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先会检查消息中的callback是否为空，这里callback就是通过post方式提交的runnable对象。如果不为空，进一步调用handleCallback()方法，这个方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">就是执行runnable的run方法，完成其中的任务。</span><br><span class="line">如果callback为空，会接着检查mCallback是否为空。前面我们已经介绍过，mCallback是handler内部定义的一个接口，提供了另一种使用Handler的方式：<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Callback)，这时就会按照callback内部的处理逻辑（自己在创建时实现）来处理方法。最后，如果mCallback为空，说明处理的是普通的message。调用handleMessage(必须在创建handler时重写，默认是一个空的方法)来处理即可。</span><br><span class="line">这样，我们就大致搞清楚了handler消息机制的主要工作原理，即handler,mq,looper三大件各自的作用及使用方法。handler使用简单，快捷，但也存在一个一直为人诟病的潜在问题：**内存泄露**。下面我们就来探讨handler引发内存泄露的问题和常用的解决方案。</span><br><span class="line"># Handler内存泄漏</span><br><span class="line">众所周知在java中，成员对象会默认隐式地持有外部类的对象。假设现在我们在MainActivity中创建了一个handler对象，那么这个handler也就持有了MainActivity的引用。现在考虑这样一种情况：如果向handler提交了一组任务，当handler还在处理任务的时候退出MainActivity会怎么样？</span><br><span class="line">正常来说，MainActivity应该被回收并释放。但由于此时handler仍在处理正在进行的任务而存在，其持有MainActivity的引用，导致gc无法及时对MainActivity进行回收。如此一来，便发生了内存泄露。</span><br><span class="line">通常情况下，handler的内存泄露都是暂时的，当其中的任务全部处理完毕时，内存还是会得到释放。但有问题就应该解决，以防止更大的问题产生。如何规避这种情况呢？</span><br><span class="line">首先我们可以想到，将handler加上<span class="keyword">static</span>修饰，**变成静态内部类**，这样handler就不会再隐式持有activity的引用了。但是这样，就又产生了一个问题：静态的handler无法访问activity实例，如果要用到activity的资源怎么办？</span><br><span class="line">方法很简单，让handler持有外部activity的**弱引用**不就好了？弱引用会在遇到gc时被回收，这样就基本上解决了问题。</span><br><span class="line">最后，我们上一个演示实例。假设现在有这样一个需求：进入app时展示欢迎界面，一段时间后跳转至另一界面。一个简单的实现是准备两个activity，用handler实现定时intent跳转。</span><br><span class="line">我们采用自定义handler的方式：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        WeakReference&lt;WelcomeActivity&gt; mactivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, WelcomeActivity activity)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);<span class="comment">//调用父类的显式指明的构造函数</span></span><br><span class="line">            mactivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;WelcomeActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="type">WelcomeActivity</span> <span class="variable">nactivity</span> <span class="operator">=</span> mactivity.get();</span><br><span class="line">            <span class="keyword">if</span>(nactivity == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(mactivity.get(), LoginActivity.class);</span><br><span class="line">                    mactivity.get().startActivity(intent);</span><br><span class="line">                    mactivity.get().finish();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我这里就采用了static和weakReference来避免内存泄露和引用activity。创建handler实例后，在activity的onCreate()中调用handler.sendEmptyMessageDelayed(0,3000);即可实现功能。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>handler消息机制是android开发重要的功能，需要我们清楚其原理和实现。<br>这是我第一次尝试自主分析源码，因此文章中可能存在错误，以及一些理解不够深入。欢迎大佬提出问题并指正！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
</search>
