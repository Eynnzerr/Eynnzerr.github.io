<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eynnzerr&#39;s Blog 复活</title>
    <url>/2025/08/29/hello-world/</url>
    <content><![CDATA[<p>在还是懵懂的大一本科生时，曾经折腾过一台服务器部署了一个博客网站，保持过一年的更新，最终却并未坚持下去。博客废弃了，域名早已过期，服务器也停机释放了。</p>
<p>三年后的今天，在整理旧电脑的数据时，无意间看到了曾经写过的几篇内容。也许文笔稚嫩，也许技术力尚欠缺，却一瞬间将我带回从前，那段时光中，最勤奋好学，贪婪地汲取知识，期待着变强的自己。</p>
<p>果然，博客还是要做下去。当再度萌生这个想法时，这个新的站点就诞生了。为了追求快速部署，采用了<strong>Github Pages</strong> + <a href="https://github.com/hexojs/hexo">Hexo</a>，主题暂且还是使用了烂大街但是确实很简约耐看的<a href="https://github.com/next-theme/hexo-theme-next">Next</a>。我会像从前一样，在这里记录自己的技术学习与实践经验，不仅为自己的反思总结，如果能帮到一些人那便更好。目前我会先对保留的老博客文章作筛选，将一部分仍有一定价值的文章搬运过来。</p>
<p>同时在技术之外，这个网站也会收录一些个人在平常的所感所想，无意义的念叨，以及生活的碎片。我想，人总归还是希望能留下些什么东西。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>Docker基础原理探究</title>
    <url>/2025/08/29/old-docker-principle/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2021年11月27日。</strong></p>
<h2 id="一、前言-Docker是什么？"><a href="#一、前言-Docker是什么？" class="headerlink" title="一、前言 Docker是什么？"></a>一、前言 Docker是什么？</h2><blockquote>
<p>Docker takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development - desktop and cloud. Docker’s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle.</p>
</blockquote>
<p>Docker是一个用Go编写的开源工具，它可以将你的应用打包成一个标准格式的镜像，并且以容器的方式运行。Docker容器将一系列软件包装在一个完整的<strong>文件系统</strong>中，这个文件系统包含应用程序运行所需要的一切：代码、运行时工具、系统工具、系统依赖，几乎有任何可以安装在服务器上的东西。这些策略保证了容器内应用程序运行环境的稳定性，不会被容器外的系统环境所影响。</p>
<p><img src="https://i.loli.net/2021/11/16/FUWQXIS5ZNdvA7Y.jpg" alt="R-C.jpeg"></p>
<h3 id="Docker容器的特点："><a href="#Docker容器的特点：" class="headerlink" title="Docker容器的特点："></a>Docker容器的特点：</h3><ol>
<li>轻量： 在同一台宿主机上的容器将共享系统kernel，使得它们可以迅速启动而且占用较少的内存。镜像是以<strong>分层文件系统</strong>构造的，这可以让它们共享相同的文件，使得磁盘使用率和镜像下载速度都得到较大提高。</li>
<li>开放： Docker容器基于开放标准，使得其可以运行在各种主流Linux Distribution和Windows，以及Mac OS上。</li>
<li>安全： 容器将各个运行的应用程序相互隔离开来，给所有的应用程序提供了一层额外的安全防护。</li>
</ol>
<h3 id="容器和虚拟机相比"><a href="#容器和虚拟机相比" class="headerlink" title="容器和虚拟机相比"></a>容器和虚拟机相比</h3><p>容器和虚拟机同样具有资源隔离和分配的功能，但由于其架构的不同，容器比虚拟机更加便捷和高效。<br>首先是犯下傲慢之罪的虚拟机，包含用户的程序，必要的函数库和整个客户操作系统，至少也需要占用好几个GB的空间。如图所示，除了使用Hypervisor技术对硬件设施进行虚拟化外，虚拟机还多一层guest OS。<br>而docker容器则是在docker engine的控制和驱动下，以用户态运行，并在宿主机上互相隔离。docker直接使用硬件资源和共享内核，不和任何基础设施绑定。</p>
<p><img src="https://i.loli.net/2021/11/16/yYOHjz3NRrJPZVp.png" alt="20006deca0fccda0d536edd626835e9e_720w.png"></p>
<h3 id="容器基本概念"><a href="#容器基本概念" class="headerlink" title="容器基本概念"></a>容器基本概念</h3><p>我们还是先回顾一波docker中的基础概念。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">镜像（Image）</td>
<td>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 centos8 就包含了完整的一套 CentOS 8 最小系统的 root 文件系统。</td>
</tr>
<tr>
<td align="center">容器（Container）</td>
<td>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</td>
</tr>
<tr>
<td align="center">仓库（Repository）</td>
<td>仓库可看成一个代码控制中心，用来保存镜像。</td>
</tr>
<tr>
<td align="center">Docker 客户端(Client）</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="center">Docker 主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="center">Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</td>
</tr>
</tbody></table>
<h2 id="二、docker的基本使用"><a href="#二、docker的基本使用" class="headerlink" title="二、docker的基本使用"></a>二、docker的基本使用</h2><p>以一个精简的UNIX工具箱busybox为例</p>
<p><code>docker pull busybox</code><br>从仓库拉取latest的busybox镜像</p>
<p><code>docker images</code><br>查看本地镜像</p>
<p><code>docker rmi  -f busybox</code><br>强制删除busybox镜像</p>
<p><code>docker run -it ubuntu /bin/bash</code><br>从镜像生成一个容器，分配伪终端，并采用交互模式运行，且在进入容器后执行&#x2F;bin&#x2F;bash</p>
<p><code>docker ps</code><br>查看所有正在运行的容器，加参数-a还可以查看停运的容器</p>
<p><code>docker start busybox</code><br>启动停止运行的容器busybox</p>
<p><code>docker stop busybox</code><br>停止正在运行的容器busybox</p>
<p><code>docker restart busybox</code><br>重启容器busybox</p>
<p><code>docker kill busybox</code><br>杀死运行中的容器busybox</p>
<p><code>docker rm -f busybox</code><br>移除容器busybox</p>
<p><code>docker pause busybox</code><br>暂停容器中所有进程</p>
<p><code>docker unpause busybox</code><br>暂停后继续容器中所有进程</p>
<p><code>docker create busybox</code><br>创建一个容器但是不启动</p>
<p><code>docker exec -it busybox /bin/bash</code><br>在正在运行的容器中执行&#x2F;bin&#x2F;bash这个命令<br>这也是进入运行中容器的一种方法</p>
<p>and so on……</p>
<h2 id="二、Docker实现原理探究"><a href="#二、Docker实现原理探究" class="headerlink" title="二、Docker实现原理探究"></a>二、Docker实现原理探究</h2><p>那么，docker是如何生成这样精简而健全的一个个容器的呢？今天，我们就来研究一波其中运用到的三个主要的功能：<strong>Linux namespace, cgroups, Union File System(UFS)</strong>。下面我们一一进行探讨。</p>
<h3 id="Linux-namespace"><a href="#Linux-namespace" class="headerlink" title="Linux namespace"></a>Linux namespace</h3><p>本来，不同的进程是共享同一份内核资源的。要做一个通俗的类比的话，如果说每个进程是单独的一个住户，那么内核资源就好比是小区里的公共场所，大家都可以使用，且使用情况对彼此都可见。而ns的作用，就是把这样的公共场所隔离开来。但这里的<strong>隔离</strong>，说的并不是将公共场所分成几部分，交给不同的进程，而是每个进程依然有原来一样大的公共场所，公共场所中的资源和变更情况只有他自己能看到。如果他在公共场所丢了一根烟头，则只有他自己知道，其他人（进程）是感知不到的。<br>Linux Namespace就是这样提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的Namespace中，来实现资源隔离的目的。不同Namespace的程序，可以享有一份独立的系统资源。<br><img src="https://i.loli.net/2021/11/16/dHxQRgG9uBOZDTr.jpg" alt="OIP-C.jpeg"><br>namespace的API有如下3个syscall:</p>
<ul>
<li>clone() 创建新进程，并根据传入的系统调用参数判断那些类型的namespace被创建，并且其子进程也会包含到这些namespace中。</li>
<li>unshare() 将进程移出某个namespace。</li>
<li>setns() 将进程加入某个namespace。</li>
</ul>
<p>目前Linux中提供了六类系统资源的隔离机制，分别是：</p>
<ul>
<li>Mount: 隔离文件系统挂载点</li>
<li>UTS: 隔离主机名和域名信息</li>
<li>IPC: 隔离进程间通信</li>
<li>PID: 隔离进程的ID</li>
<li>Network: 隔离网络资源</li>
<li>User: 隔离用户和用户组的ID</li>
<li>Cgroup: 隔离cgroup根目录（最新，尚未被docker采用）<br>下面一一解释他们的作用：</li>
</ul>
<h4 id="Mount-namespace"><a href="#Mount-namespace" class="headerlink" title="Mount namespace"></a>Mount namespace</h4><p>Mount Namespace用来<em>隔离各个进程看到的挂载点视图</em>。不同namespace的进程，看到的文件系统层次是不同的。在mount namespace中调用mount, umount等命令只会影响当前namespace内的文件系统，而对全局的文件系统是没有影响的。（事实上，docker容器内的挂载情况确实和宿主机不同。）<br>Mount Namespace是linux第一个实现的namespace类型，因而它的syscall参数比较特殊，是NEWNS。<br><img src="https://i.loli.net/2021/11/16/amiSFvLeyJ6k5A7.png" alt="ns-mount.png"><br>但是有一点需要注意：有些时候，Mount Namespace其实并不能真正隔离挂载信息！这是因为linux中还存在一种名为<strong>Shared Subtree</strong>的机制！<br>引入该机制是为了消除mount ns带来的不便，比如系统新增一块磁盘，我希望所有的NS都感知到新挂载的这块磁盘，那么如果NS 之间是完全隔离的，就需要每个都执行一次挂载操作，这是非常不变的，shared subtree保证了不同的NS 之间可以共享挂载信息。<br>共享子树有两大核心：<strong>peer group</strong>和<strong>propagate type</strong>。</p>
<ul>
<li>peer group<br>表示了一个或多个挂载点的集合，下面两种情况属于统一group：</li>
</ul>
<p>通过–bind操作挂载的源挂载点和目标挂载点（前提是源目录是个挂载点）<br>生成新mount ns时，复制过去的挂载点之间同在一个group</p>
<ul>
<li>propagate type(传播属性)<br>这是mount点的属性，其常见值有：</li>
</ul>
<ol>
<li>MS_SHARED  该挂载点的删除操作、该挂载点下子挂载点的新增和删除操作都会同步到同一group中的其他mount点，且其他同group的mount点的操作也会同步到该mount点</li>
<li>MS_PRIVATE  与1相反，不会将自己的信息共享出去，也不接受其他点的共享，从而实现真正的隔离</li>
<li>MS_SLAVE  单向的共享，自己的更新不会影响到他人，但是他人的操作会同步到自己</li>
</ol>
<p>通过以下命令当前挂载点的传播属性：<br><code>cat /proc/self/mountinfo </code><br>可以发现所有进程默认情况下都是shared的。又因为通过系统调用clone出的namespace与父进程处在一个peer group下，所以会完全copy父进程的挂载点信息，因此子进程的挂载点也是shared。如果不注意到这点的话，创建的容器就不会真正隔绝挂载信息，且会引起一些不妙的后果。我们放在后面构建简单docker容器的实战中再说这个bug。</p>
<h4 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h4><p>UTS namespace主要用来<em>nodename和domainname</em>两个系统标识。也就是说，每个UTS Namespace被允许有自己的主机名（docker网络通信的重要基础之一）。<br>我们可以通过一个简单的Go语言demo来验证UTS namespace的作用：</p>
<pre><code>func main() &#123;
    cmd := exec.Command(&quot;sh&quot;)//指定新进程的初始命令
    cmd.SysProcAttr = &amp;syscall.SysProcAttr &#123;
        CloneFlags: syscall.CLONE_NEWUTS,
    &#125;//设定系统调用属性
    cmd.Stdin = os.Stdin
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr//设置标准输入输出

    if err := cmd.Run(); err != nil &#123;
        log.Fatal(err)
    &#125;//运行命令和错误处理
&#125;
</code></pre>
<p>执行代码，在启动的交互式环境里，先用echo $$输出一下当前进程的PID，再用pstree -pl查看进程树，找到父进程。由于在进程目录下的ns目录包含进程的namespace信息，其中uts就对应 UTS namespace的信息。且由于ns目录下的这些文件其实都是特殊的符号链接，所以需要用readlink读取其实际指向的内容，便可以知道其UTS namespace的inode号了。于是用readlink &#x2F;proc&#x2F;xxxxx&#x2F;ns&#x2F;uts比较ns的inode，可以验证他们不在同一个UTS Namespace中。<br>接着，执行hostname -b chenpeng，修改当前主机名。另外启动一个shell，使用hostname命令，会发现外部的hostname并未因内部的修改而改变，证明了UTS Namespace的作用。<br>其他namespace的作用可以类似地验证，接下来就主要介绍他们的作用即可。</p>
<h4 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h4><p>用来隔离System V IPC和POSIX message queues。</p>
<h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h4><p>用来隔离进程ID。同样一个进程在不同的PID Namespace中可以拥有不同的PID。可以通过分别在宿主机和容器内执行ps -ef验证docker对这个namespace的运用。</p>
<h4 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h4><p>用来隔离用户的用户组ID。也就是说，一个进程的User ID和Group ID在User Namespace内外可以是不同的。比如在宿主机上的以非root用户运行创建一个User Namespace，而在namespace里面这个用户被映射为root用户。这意味着，这个进程在User Namespace里拥有root权限，但在外面却没有。从Linux Kernel 3.8开始，非root进程也可以创建User Namespace并被映射成root。</p>
<h4 id="Netwoek-Namespace"><a href="#Netwoek-Namespace" class="headerlink" title="Netwoek Namespace"></a>Netwoek Namespace</h4><p>用来隔离网络设备、IP地址端口等网络栈。可以让每个容器拥有自己独立的虚拟网络设备，且容器内的应用可以绑定到自己的端口，使得各个Namespace内的端口不会互相冲突。且在宿主机上搭建网桥后，可以很方便地实现容器间通信。此外，通过端口映射，可以使得不同容器上的应用使用相同的端口号。</p>
<h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>namespace技术可以帮助构建出的容器拥有自己与外部隔离的单独的空间，但Docker是如何限制每个容器所占空间的大小，从而保证它们不会相互争抢的呢？这就要运用Cgroups技术。<br>Linux Cgroups（Control Groups）提供了对一组进程及其将来子进程的资源限制、控制和统计的能力，这些资源包括CPU,内存，存储，网络等。通过Cgroups，可以方便地限制某个进程的资源占用，并且实时地监控进程和统计信息。<br>比如可以通过cgroup限制特定进程使用特定数目的cpu核数和特定大小的内存，如果资源超限的情况下，会被暂停或者杀掉。</p>
<ul>
<li>任务(task): 在cgroups中，task就是一个进程或线程。</li>
<li>控制组(control group): cgroups的资源控制是以cgroup的方式实现，cgroup指明了资源的配额限制。进程可以加入到某个cgroup，也可以迁移到另一个cgroup。</li>
<li>层级(hierarchy): cgroup有层级关系，类似树的结构，子节点的cgroup继承父cgroup的属性(资源配额、限制等)。</li>
<li>子系统(subsystem): 一个subsystem其实就是一种资源的控制器，比如memory subsystem可以控制进程内存的使用。subsystem需要加入到某个hierarchy，然后该hierarchy的所有cgroup，均受到这个subsystem的控制。<br>subsystem的类别：<ul>
<li>cpu: 限制进程的 cpu 使用率。</li>
<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li>cpuset: 为cgroups中的进程分配单独的cpu节点或者内存节点。</li>
<li>memory: 限制进程的memory使用量。</li>
<li>blkio: 限制进程的块设备io。</li>
<li>devices: 控制进程能够访问某些设备。</li>
<li>net_cls: 标记cgroups中进程的网络数据包，然后可以使用tc模块（traffic control）对数据包进行控制。</li>
<li>net_prio: 限制进程网络流量的优先级。</li>
<li>huge_tlb: 限制HugeTLB的使用。</li>
<li>freezer:挂起或者恢复cgroups中的进程。</li>
<li>ns: 控制cgroups中的进程使用不同的namespace。</li>
</ul>
</li>
</ul>
<p>也就是说，cgroup是管理一组task的基本单元，其作为结点组成的树结构叫做hiierarchy。subsystem附加在hierarchy上，对其中的cgroup进行资源限制，同时子结点继承父结点的配置。<br><img src="https://i.loli.net/2021/11/16/nXhgHSrBY5IZ9oq.png" alt="cgroup.png"><br>三个组件的关系：系统创建新的hierarchy后，系统中的所有进程都会加入这个hierarchy的cgroup根节点，这个根节点是由hierarchy默认创建的。一个subsystem只能附加到一个hierarchy上面，一个hierarchy可以附加多个subsystem，一个进程可以作为多个cgroup的成员，但这些cgroup必须在不同的hierarchy中；一个进程fork出子进程时，父子同属于一个cgroup，但也可以根据需要移到不同的cgroup中。<br>如何调用内核才能配置Cgroups呢？前面提到，hierarchy是一种树状的组织结构，kernel为了使对Cgroups的配置更加直观，是通过一个虚拟的树状文件系统来配置Cgroup的，也就是通过层级的目录来虚拟出一棵hierarchy(cgroup tree)。示例：</p>
<pre><code>mkdir cgroup-test
sudo mount -t cgroup -o none, name=cgroup-test cgroup-test ./cgroup-test
ls ./cgroup-test
</code></pre>
<p>以上在当前目录创建一个文件夹，并挂载了一个cgroup类型的文件系统，这样就创建了一棵hierarchy。ls查看一下目录，会发现生成了一些默认的文件：</p>
<ul>
<li><p>cgroup.clone_children cpuset的subsystem会读取这个配置文件,如果这个值(默认值是0)是 1 子cgroup才会继承父cgroup的cpuset的配置</p>
</li>
<li><p>cgroup.procs是树中当前节点cgroup中的进程组ID,现在的位置是根节点,这个文件中会有现在系统中所有进程组的ID</p>
</li>
<li><p>notify_on_release和release_agent 会一起使用。notify_on_release 标志当这个cgroup最后一个进程退出的时候是否执行了release_agent</p>
</li>
<li><p>release_agent 则是一个路径,通常用作进程退出后自动清理不再使用的cgroup</p>
</li>
<li><p>task 标识该cgroup下面进程ID,如果把一个进程ID写到task文件中,便会把相应的进程加入到这个cgroup中。<br>在该目录下继续创建文件夹，就是扩展子cgroup，其也会自动创建一些文件配置项。<br>但是由于我们创建的这个hierarchy没有附加任何subsystem（-o 后的值为none），所以没办法对其中的cgroup限制进程资源占用。值得一提的是，各种subsystem在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;下有系统已经创建好的默认的hierarchy，因而很方便我们使用。(或者也可以使用-o memory)<br>在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory下：</p>
<p>  sudo mkdir test &amp;&amp; cd test<br>  sudo sh -c “echo “100m” &gt; memory.limit_in_bytes”<br>  sudo sh -c “echo $$ &gt; tasks”<br>  stress –vm-bytes 200m –vm-keep -m 1</p>
</li>
</ul>
<p>以上，我们在挂载了memory子系统的hierarchy下创建了一个cgroup，并通过修改配置项对其内存资源限制（200m以下），然后使用stress进行压力测试。<br>使用top等命令可以发现，其内存确实被限制，验证了cgroups的限制资源的能力。<br>在Docker中，我们可以在启动一个容器的时候传入参数-m 100m达到这种效果，即将容器的内存占用限制在100m，这背后就是由cgroups技术实现的。Dokcer通过为每个容器创建cgroup,配置资源限制和监控。</p>
<h3 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h3><p>Union FS，是一种为linux,fressBSD,netBSD操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录透明地覆盖，形成一个单一的文件系统。这些branch或者是ro的，或者是rw的，所以当对这个虚拟后的联合文件系统进行写操作时，系统是真正写到了一个新文件中。看起来这个虚拟后的联合文件系统可以对任何文件进行操作，但其实并没有改变原来的文件，这是因为unionfs使用了一个重要的资源管理技术——<strong>写时复制</strong>(copy-on-write)。<br>coW，也叫做隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时不需要立即创建一个新的资源，这个资源可以被新旧实例共享。创建新资源只会发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著减少未修改资源的复制所带来的消耗。</p>
<h4 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h4><p>AUFS，全称是Advanced Multi-Layerd Unification Filesystem，完全重写了早期的UnionFS 1.x，并引入了一些新的功能，比如可写分支的负载均衡。<br>AUFS是docker选用的第一种存储驱动，具有快速启动容器、高效利用存储和内存等优点，直到现在依然被docker支持。接下来，介绍docker是如何利用AUFS存储镜像和容器的。<br>我们知道，在docker中，每一个image都是由一系列read-only layer组成的。image layer的内容都存储在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;diff目录下。而&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;layers目录则存储image layer如何堆栈这些layer的metadata。</p>
<p><img src="https://i.loli.net/2021/11/16/xpBINYUX5t6Mzlc.jpg" alt="container-layers.jpg"></p>
<h4 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h4><p>Overlay2是现版本Docker默认使用的存储驱动，通常情况下，overlay2 会比AUFS性能更好，而且更加稳定，但是二者基本的存储思路都是分层。overlay2 和 AUFS 类似，它将所有目录称之为层（layer），overlay2 的目录是镜像和容器分层的基础，而把这些层统一展现到同一的目录下的过程称为联合挂载（union mount）。overlay2 把目录的下一层叫作lowerdir，上一层叫作upperdir，联合挂载后的结果叫作merged。<br>总体来说，overlay2 是这样储存文件的：overlay2将镜像层和容器层都放在单独的目录，并且有唯一 ID，每一层仅存储发生变化的文件，最终使用联合挂载技术将容器层和镜像层的所有文件统一挂载到容器中，使得容器中看到完整的系统文件。</p>
<p>接下来以overlay2为例，探究docker是如何存放镜像的。<br>首先从仓库拉取一个ubuntu16.04镜像，然后查看该镜像的信息：</p>
<p><code>docker pull ubuntu:16.04</code><br>观察到如下信息：</p>
<pre><code>16.04: Pulling from library/ubuntu
58690f9b18fc: Pull complete 
b51569e7c507: Pull complete 
da8ef40b9eca: Pull complete 
fb15d46c38dc: Pull complete 
Digest: sha256:0f71fa8d4d2d4292c3c617fda2b36f6dabe5c8b6e34c3dc5b0d17d4e704bd39c
Status: Downloaded newer image for ubuntu:16.04
</code></pre>
<p>可以看到，镜像正是被分为4层拉取下来的。在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2可以找到所有拉取下来的layer。此外，该目录下还有一个l目录，这里全是到各层diff之间的软链接，把一些较短的随机串软连到镜像层的 diff 文件夹下，这样做是为了避免达到mount命令参数的长度限制。<br>先随意查看一个镜像层的内容：diff,link,lower,work。<br>在这里，link 文件内容为该镜像层对应l目录中的短 ID，diff 文件夹为该镜像层的改动内容，也是被联合挂载的内容，lower 文件为该层的所有父层镜像的短 ID，规定了镜像间的层序关系。<br>我们可以用docker inspect来找到某个镜像的层级之间的关系：</p>
<pre><code>docker image inspect ubuntu
...
&quot;GraphDriver&quot;: &#123;
            &quot;Data&quot;: &#123;
                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/ca36b188418e7d85232c6d90144380e543ec45fb4cc962bf2f45d4a823c0f9cd/diff:/var/lib/docker/overlay2/4f934d2bbd300caf92c0f00c85201053c20881c91810f32c5bef850581990acd/diff:/var/lib/docker/overlay2/579a385ff86c563d0c4c71bcc5471133b674d102de7ab38555e66ec955f5dcdb/diff&quot;,
                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/merged&quot;,
                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/diff&quot;,
                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/work&quot;
            &#125;,
            &quot;Name&quot;: &quot;overlay2&quot;
        &#125;,
...
</code></pre>
<p>其中 MergedDir 代表当前镜像层在 overlay2 存储下的目录，LowerDir 代表当前镜像的父层关系，使用冒号分隔，冒号最后代表该镜像的最底层。<br>接着启动容器，再用docker inspect查看容器的层级关系：</p>
<pre><code>docker inspect ubuntu
...
&quot;GraphDriver&quot;: &#123;
        &quot;Data&quot;: &#123;
            &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d-init/diff:/var/lib/docker/overlay2/aac78f83be662b8ec26fadd30aff555f35f66453b834a1d71edd7aea83607b40/diff:/var/lib/docker/overlay2/ca36b188418e7d85232c6d90144380e543ec45fb4cc962bf2f45d4a823c0f9cd/diff:/var/lib/docker/overlay2/4f934d2bbd300caf92c0f00c85201053c20881c91810f32c5bef850581990acd/diff:/var/lib/docker/overlay2/579a385ff86c563d0c4c71bcc5471133b674d102de7ab38555e66ec955f5dcdb/diff&quot;,
            &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/merged&quot;,
            &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/diff&quot;,
            &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/f5de3e3e085c8c0a6591705d368523927ba6e3fd5434ba802a3315d6747ce00d/work&quot;
        &#125;,
        &quot;Name&quot;: &quot;overlay2&quot;
    &#125;,
...
</code></pre>
<p>这里MergedDir 的内容即为容器层的工作目录，LowerDir 为容器所依赖的镜像层目录。实际上，overlay2将lowerdir、upperdir、workdir联合挂载，形成最终的merged挂载点，其中lowerdir是镜像只读层，upperdir是容器可读可写层，workdir是执行涉及修改lowerdir执行copy_up操作的中转层（例如，upperdir中不存在，需要从lowerdir中进行复制，该过程暂未详细了解，遇到了再分析）。</p>
<h3 id="实战：自制简单docker"><a href="#实战：自制简单docker" class="headerlink" title="实战：自制简单docker"></a>实战：自制简单docker</h3><p>明白了以上三个基本原理，实际上我们已经可以制作一个简单的小docker了！这里为了方便，还是使用AUFS作为存储。<br>首先，使用go的urfave&#x2F;cli命令行工具，将代码改造成命令行程序：</p>
<pre><code>const usage = `we make a small docker container by ourselves using basic knowledge.`

func main() &#123;
    app := cli.NewApp()
    app.Name = &quot;mydocker&quot;
    app.Usage = usage

    app.Commands = []cli.Command&#123;
        initCommand,
        runCommand,
    &#125;

    app.Before = func(context *cli.Context) error &#123;
        // Log as JSON instead of the default ASCII formatter.
        log.SetFormatter(&amp;log.JSONFormatter&#123;&#125;)

        log.SetOutput(os.Stdout)
        return nil
    &#125;

    if err := app.Run(os.Args); err != nil &#123;
        log.Fatal(err)
    &#125;
&#125;
</code></pre>
<p>这里我们规定了2条命令：run和init，其中run就和docker run一样是启动容器，而init是内部调用的用于初始化容器的命令。接着，我们详细定义这两条命令：</p>
<pre><code>var runCommand = cli.Command&#123;
    Name: &quot;run&quot;,
    Usage: `Create a container with namespace and cgroups limit
            mydocker run -ti [command]`,
    Flags: []cli.Flag&#123;
        cli.BoolFlag&#123;
            Name:  &quot;ti&quot;,
            Usage: &quot;enable tty&quot;,
        &#125;,
    &#125;,
    Action: func(context *cli.Context) error &#123;
        if len(context.Args()) &lt; 1 &#123;
            return fmt.Errorf(&quot;Missing container command&quot;)
        &#125;
        var cmdArray []string
        for _, arg := range context.Args() &#123;
            cmdArray = append(cmdArray, arg)
        &#125;
        tty := context.Bool(&quot;ti&quot;)
        Run(tty, cmdArray)
        return nil
    &#125;,
&#125;

var initCommand = cli.Command&#123;
    Name:  &quot;init&quot;,
    Usage: &quot;Init container process run user&#39;s process in container. Do not call it outside&quot;,
    Action: func(context *cli.Context) error &#123;
        log.Infof(&quot;init come on&quot;)
        err := container.RunContainerInitProcess()
        return err
    &#125;,
&#125;
</code></pre>
<p>其中flags规定了一些调用参数，如ti就和docker中一样，意义是启动终端和交互。action是命令真正的入口，这里先判断有无命令，再读取args将命令存入cmdArray。最后调用了Run函数：</p>
<pre><code>func Run(tty bool, comArray []string) &#123;
    parent, writePipe := container.NewParentProcess(tty)
    if parent == nil &#123;
        log.Errorf(&quot;New parent process error&quot;)
        return
    &#125;
    if err := parent.Start(); err != nil &#123;
        log.Error(err)
    &#125;
    sendInitCommand(comArray, writePipe)
    parent.Wait()
    mntURL := &quot;/cproot/mnt/&quot;
    rootURL := &quot;/cproot/&quot;
    container.DeleteWorkSpace(rootURL, mntURL)
    os.Exit(0)
&#125;

func sendInitCommand(comArray []string, writePipe *os.File) &#123;
    command := strings.Join(comArray, &quot; &quot;)
    log.Infof(&quot;command all is %s&quot;, command)
    writePipe.WriteString(command)
    writePipe.Close()
&#125;
</code></pre>
<p>接着，首先调用了NewParentProcess函数，如下：</p>
<pre><code>func NewParentProcess(tty bool) (*exec.Cmd, *os.File) &#123;
    readPipe, writePipe, err := NewPipe()
    if err != nil &#123;
        log.Errorf(&quot;New pipe error %v&quot;, err)
        return nil, nil
    &#125;
    cmd := exec.Command(&quot;/proc/self/exe&quot;, &quot;init&quot;)
    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;
        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS |
            syscall.CLONE_NEWNET | syscall.CLONE_NEWIPC,
    &#125;
    if tty &#123;
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
    &#125;
    cmd.ExtraFiles = []*os.File&#123;readPipe&#125;
    mntURL := &quot;/cproot/mnt/&quot;
    rootURL := &quot;/cproot/&quot;
    NewWorkSpace(rootURL, mntURL)
    cmd.Dir = mntURL
    return cmd, writePipe
&#125;

func NewPipe() (*os.File, *os.File, error) &#123;
    read, write, err := os.Pipe()
    if err != nil &#123;
        return nil, nil, err
    &#125;
    return read, write, nil
&#125;
</code></pre>
<p>这里先调用NewPipe创建了用于外部和容器通信的管道，接着设置了需要执行的两条命令：<br>&#x2F;proc&#x2F;self&#x2F;exe 当前正在运行的进程本身的可执行文件，这就是自己调用自己，来初始化刚创建出的进程。<br>init 就是刚刚自定义的命令。<br>接着设置了系统调用属性：这里就是fork出一个新进程，且为这个进程设置了若干namespace，来与外部环境进行隔离。<br>由于进程的3个文件描述符已经被标准输入、输出、错误所占用，所以就通过extraFiles传入了管道读取端给子进程。接着规定了，联合文件系统最终的挂载目录和镜像、容器layer所在的目录。紧接着便调用了NewWorkSpace函数：</p>
<pre><code>func NewWorkSpace(rootURL string, mntURL string) &#123;
    CreateReadOnlyLayer(rootURL)
    CreateWriteLayer(rootURL)
    CreateMountPoint(rootURL, mntURL)
&#125;

func CreateReadOnlyLayer(rootURL string) &#123;
    busyboxURL := rootURL + &quot;busybox/&quot;
    busyboxTarURL := rootURL + &quot;busybox.tar&quot;
    exist, err := PathExists(busyboxURL)
    if err != nil &#123;
        log.Infof(&quot;Fail to judge whether dir %s exists. %v&quot;, busyboxURL, err)
    &#125;
    if exist == false &#123;
        if err := os.Mkdir(busyboxURL, 0777); err != nil &#123;
            log.Errorf(&quot;Mkdir dir %s error. %v&quot;, busyboxURL, err)
        &#125;
        if _, err := exec.Command(&quot;tar&quot;, &quot;-xvf&quot;, busyboxTarURL, &quot;-C&quot;, busyboxURL).CombinedOutput(); err != nil &#123;
            log.Errorf(&quot;Untar dir %s error %v&quot;, busyboxURL, err)
        &#125;
    &#125;
&#125;

func CreateWriteLayer(rootURL string) &#123;
    writeURL := rootURL + &quot;writeLayer/&quot;
    if err := os.Mkdir(writeURL, 0777); err != nil &#123;
        log.Errorf(&quot;Mkdir dir %s error. %v&quot;, writeURL, err)
    &#125;
&#125;

func CreateMountPoint(rootURL string, mntURL string) &#123;
    if err := os.Mkdir(mntURL, 0777); err != nil &#123;
        log.Errorf(&quot;Mkdir dir %s error. %v&quot;, mntURL, err)
    &#125;
    dirs := &quot;dirs=&quot; + rootURL + &quot;writeLayer:&quot; + rootURL + &quot;busybox&quot;
    cmd := exec.Command(&quot;mount&quot;, &quot;-t&quot;, &quot;aufs&quot;, &quot;-o&quot;, dirs, &quot;none&quot;, mntURL)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil &#123;
        log.Errorf(&quot;%v&quot;, err)
    &#125;
&#125;
</code></pre>
<p>这个函数分为3个部分，首先是创建镜像层（只读），接着是创建容器可写层，最后就是用AUFS的方式将容器层、可写层联合挂载到指定的mntURL下。<br>通过调用newparentprocess，我们就从返回值得到了这样的一条命令，并在Run函数中对其调用start函数，这才是真正开始这条命令的执行，它会首先clone出一个namespace隔离的进程，并在子进程中先调用&#x2F;proc&#x2F;self&#x2F;exe，即其本身，接着调用我们写的init方法，进行初始化。然后便开始执行sendInitCommand函数，即将用户输入的命令读取到管道的写入端。当程序执行完毕后，会调用wait释放进程资源并退出，以及执行DeleteWorkSpace删除可写层和解挂aufs系统（相当于退出容器），这些都是后话。<br>生成子进程后，首先会调用自己，即启动子进程。接着子进程就会执行init命令，调用RunContainerInitProcess()。也就是说，调用这个函数时，我们已经身处namespace内的子进程了：</p>
<pre><code>func RunContainerInitProcess() error &#123;
    cmdArray := readUserCommand()
    if cmdArray == nil || len(cmdArray) == 0 &#123;
        return fmt.Errorf(&quot;Run container get user command error, cmdArray is nil&quot;)
    &#125;

    setUpMount()

    path, err := exec.LookPath(cmdArray[0])
    if err != nil &#123;
        log.Errorf(&quot;Exec loop path error %v&quot;, err)
        return err
    &#125;
    log.Infof(&quot;Find path %s&quot;, path)
    if err := syscall.Exec(path, cmdArray[0:], os.Environ()); err != nil &#123;
        log.Errorf(err.Error())
    &#125;
    return nil
&#125;

func readUserCommand() []string &#123;
    pipe := os.NewFile(uintptr(3), &quot;pipe&quot;)
    msg, err := ioutil.ReadAll(pipe)
    if err != nil &#123;
        log.Errorf(&quot;init read pipe error %v&quot;, err)
        return nil
    &#125;
    msgStr := string(msg)
    return strings.Split(msgStr, &quot; &quot;)
&#125;

/**
Init 挂载点
*/
func setUpMount() &#123;
    pwd, err := os.Getwd()
    if err != nil &#123;
        log.Errorf(&quot;Get current location error %v&quot;, err)
        return
    &#125;
    log.Infof(&quot;Current location is %s&quot;, pwd)
    pivotRoot(pwd)

    //mount proc
    defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
    quarantineMountFlags := syscall.MS_PRIVATE | syscall.MS_REC
    syscall.Mount(&quot;&quot;,&quot;/&quot;,&quot;&quot;, uintptr(quarantineMountFlags), &quot;&quot;)
    syscall.Mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, uintptr(defaultMountFlags), &quot;&quot;)

    //syscall.Mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, syscall.MS_NOSUID|syscall.MS_STRICTATIME, &quot;mode=755&quot;)
&#125;

func pivotRoot(root string) error &#123;
    /**
    为了使当前root的老 root 和新 root 不在同一个文件系统下，我们把root重新mount了一次
    bind mount是把相同的内容换了一个挂载点的挂载方法
    */
    log.Infof(&quot;pivotroot: root is %s&quot;, root)
    if err := syscall.Mount(root, root, &quot;bind&quot;, syscall.MS_BIND|syscall.MS_REC, &quot;&quot;); err != nil &#123;
        return fmt.Errorf(&quot;Mount rootfs to itself error: %v&quot;, err)
    &#125;
    // 创建 rootfs/.pivot_root 存储 old_root
    pivotDir := filepath.Join(root, &quot;.pivot_root&quot;)
    if err := os.Mkdir(pivotDir, 0777); err != nil &#123;
        return err
    &#125;
    // pivot_root 到新的rootfs, 现在老的 old_root 是挂载在rootfs/.pivot_root
    // 挂载点现在依然可以在mount命令中看到
    if err := syscall.PivotRoot(root, pivotDir); err != nil &#123;
        return fmt.Errorf(&quot;pivot_root %v&quot;, err)
    &#125;
    // 修改当前的工作目录到根目录
    if err := syscall.Chdir(&quot;/&quot;); err != nil &#123;
        return fmt.Errorf(&quot;chdir / %v&quot;, err)
    &#125;

    pivotDir = filepath.Join(&quot;/&quot;, &quot;.pivot_root&quot;)
    // umount rootfs/.pivot_root
    if err := syscall.Unmount(pivotDir, syscall.MNT_DETACH); err != nil &#123;
        return fmt.Errorf(&quot;unmount pivot_root dir %v&quot;, err)
    &#125;
    // 删除临时文件夹
    return os.Remove(pivotDir)
&#125;
</code></pre>
<p>首先是调用readCommand从管道读取用户传入的命令，并在后来识别系统环境变量并予以执行。接着调用setupMount开始一系列挂载工作。这里读取到的pwd就是指定的mntURL，也就是联合文件系统的挂载点，容器的工作目录。接着，调用pivotRoot(pwd)。众所周知，pivot_root是一个系统调用，主要功能是改变当前的rootfs。pivot_root可以将当前进程的rootfs移动到put_old文件夹，再使new_root成为新的rootfs。new_root和put_old必须不能同时存在当前root的同一个文件系统中。这个系统调用和chroot命令区别在于，前者是将整个系统切换到一个新的root目录，并移除对之前root文件系统的依赖，这样就能umount原先的rootfs。而后者只是针对某个进程，系统的其他部分依旧运行于老的root目录中。<br>注意！在挂载开始前，我们首先有这样的操作：</p>
<pre><code>quarantineMountFlags := syscall.MS_PRIVATE | syscall.MS_REC
syscall.Mount(&quot;&quot;,&quot;/&quot;,&quot;&quot;, uintptr(quarantineMountFlags), &quot;&quot;)
</code></pre>
<p>这就是开始将mount namespace时提出的，其作用相当于mount –make-rprivate &#x2F;,即递归修改整个mount树的propagate type为private，这样我们在容器内的挂载操作才不会传给外部。否则在接下来挂载proc后，回到主机系统，会发现很多命令都无法使用了。这其实就是因为主机的proc被修改了，需要在主机重新mount一次proc才能恢复正常。<br>这之后，init命令的工作也就做完了，此时我们的容器已启动起来。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>namespace</tag>
        <tag>Cgroups</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler 消息处理机制解析</title>
    <url>/2025/08/29/old-handler-src-analysis/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2021年9月11日。</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提到Android中的消息机制，想必大家对其都不陌生。Android消息机制，一般指handler和其附加的mq及looper的运行机制与工作过程。handler常用于解决在子线程不能访问UI的问题，举一个常见的例子：我们在子线程中执行了耗时工作后，需要对UI进行更新，但又不能直接在子线程更新UI（这是因为控件在重绘前会调用checkThread()检查当前是否为主线程，以防ANR）。此时我们就可以创建handler，并将要执行的代码逻辑写入一个runnable任务中，并调用handler的post(本质上仍是调用send)或send将任务提交给主线程的消息队列中，再由主线程的looper取出这个任务，在主线程执行，如此便自然地从子线程转入主线程，实现了UI的更新。当然我们也可以直接调用Activity类的runOnUiThread()方法，道理是一样的。下面就让我们一起从源码的角度探究handler消息处理机制的原理，以及handler使用存在的一些问题。</p>
<h1 id="handler的构造问题"><a href="#handler的构造问题" class="headerlink" title="handler的构造问题"></a>handler的构造问题</h1><p>handler有多个构造方法，我们常常用到的有以下几个：</p>
<ol>
<li>无参构造</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法已经弃用。其内部调用了另一个有参构造方法，但是传的值为null和false，让我们接下去看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先解释一下这个构造方法的参数：callback是handler中定义的一个接口，用于简化构建handler的过程（可以用实现这个接口来避免自定义handler子类），下文再对这个接口做详细解释。这里传入值为null，说明我们不采用这种方式。async标志这个handler是否采用异步消息，下文再对handler的异步、普通和屏障消息作区别以及介绍同步屏障机制。这里传入false，说明我们默认采用的都是普通消息机制。<br>这个构造方法首先会通过FIND_POTENTIAL_LEAKS判断是否由可能存在的内存泄漏情况，如果有，则会输出日志警告我们。（不过我没有找到设置这个bool值为true的代码部分。。。）关于handler潜在的内存泄漏风险，下文会重点讨论。接着调用Looper.myLooper()尝试获取当前线程的looper。我们进入这个方法看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了sThreadLocal的get方法并返回。那么sThreadLocal是什么呢？找到定义如下：</p>
<pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
</code></pre>
<p>发现这是一个ThreadLocal变量。关于ThreadLocal这里不做过多介绍（计划单独写一篇博客研究一下ThreadLocal，毕竟也是一个十分重要的知识点）。这样以来就明确了：每个线程只能有最多一个looper，并且存储在threadLocal里。调用get便可以得到当前线程的looper。但是除了主线程以外（主线程的消息机制下文会重点讨论），线程默认是没有looper的，需要自己通过prepare创建。如此，get方法就有可能返回null。当返回null时，就会抛出异常。以上我们可以得出一个结论：使用无参构造方法，必须确保当前线程持有looper，否则就会导致异常抛出。因此，这个方法被废弃也就不足为奇了。相应地，google建议我们使用另一个构造方法代替：<br>2. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(looper, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个构造方法同样在内部调用了另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里直接使用了参数指定的looper，并获得了其对应的消息队列。</p>
<h1 id="MQ的工作原理"><a href="#MQ的工作原理" class="headerlink" title="MQ的工作原理"></a>MQ的工作原理</h1><p>现在我们有了handler对象，并且这个handler内部持有某个线程的looper和messageQueue的对象。接着，就可以调用handler的send&#x2F;post方法发送消息了。由于查看源码可以知道post方法本质上还是将runnable包装成message后调用send系列方法，所以这里就直接看send系列方法。譬如调用sendMessage方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了另一个方法sendMessageDelayed。由此可见，我们也可以直接调用sendMessageDelayed并指定一个延迟时间，实现<strong>定时任务</strong>的效果。走进这个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又调用了另一个方法sendMessageAtTime。走进这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">可以看见，首先方法试图获取一个消息队列，如果获取不到则会发出警告并返回<span class="literal">false</span>，那么消息则发送失败，不了了之。否则，接下来会调用enqueueMessage方法，走进这个方法：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">        msg.target = <span class="built_in">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">直接看最后一行，发现经过一系列方法，最终调用的是消息队列的enqueueMessage方法，也是消息队列工作较为重要的一个方法。走进这个方法：</span><br><span class="line">```java</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> <span class="keyword">when</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                            msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">                    Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                    msg.recycle();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                msg.markInUse();</span><br><span class="line">                msg.<span class="keyword">when</span> = <span class="keyword">when</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">                <span class="type">boolean</span> needWake;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> == <span class="number">0</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                    msg.next = p;</span><br><span class="line">                    mMessages = msg;</span><br><span class="line">                    needWake = mBlocked;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">                    <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                    <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                    needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                    Message prev;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        prev = p;</span><br><span class="line">                        p = p.next;</span><br><span class="line">                        <span class="keyword">if</span> (p == <span class="literal">null</span> || <span class="keyword">when</span> &lt; p.<span class="keyword">when</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                            needWake = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                    prev.next = msg;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">                <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                    nativeWake(mPtr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">```        </span><br><span class="line">虽然上面的代码比较长，但其实只做了一件很简单的事情：向消息队列插入当前消息。</span><br><span class="line">首先，我们要了解消息队列底层采用的数据结构。虽然称作队列，其本质上只是一个普通的单链表。这点可从message类的源码印证：</span><br><span class="line">```java</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="comment">/*package*/</span> Message next;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>每个message对象都有一个next指针域。<br>enqueueMessage首先会对一些特殊情况进行处理，接着上了synchronize保证对链表的访问是线程安全的。接着分两种情况：第一次插入，唤醒阻塞的队列并创建新头，插入第一条消息，否则就尾插到链表尾部。<br>那么，looper是如何取出mq中的消息的呢？这里就要调用另一个方法next()了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.<span class="keyword">when</span>) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.<span class="keyword">when</span> - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.<span class="keyword">when</span>)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中涉及到许多值得注意的地方，比如同步屏障机制的实现等。但目前我们只关心next()方法的主要作用：取出消息队列中下一个消息。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line"><span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Stalled by a barrier.  Find the next asynchronousmessage in the queue.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prevMsg = msg;</span><br><span class="line">        msg = msg.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.<span class="keyword">when</span>) &#123;</span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.<span class="keyword">when</span> - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line"><span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">    dispose();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取了当前系统时间now。接着开始遍历消息队列。如果遇到屏障，则跳过普通消息寻找下一个异步消息（暂且不管）。而如果遍历到的消息的when字段大于当前时间，说明这个消息还未准备好，于是不先取出而是设置了一个唤醒时间，等到时间时再取出。否则，取出当前消息，并返回给调用者（looper）。而如果迟迟没有返回，消息队列就会设置nextPollTimeoutMillis为-1，并无限循环地阻塞下去，直到取出并返回可用的消息。最后是消息队列退出时的一些善后操作。<br>如此以来，消息队列的工作原理我们就大致清晰了。</p>
<h1 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h1><p>handler负责发送和接收消息，message queue负责按FIFO方式存储消息，而looper则负责无限期地从mq中取出消息并分发给handler。looper的核心方法是loop()。<br>我们先了解一些looper类的字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Observer sObserver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> mInLoop;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> Printer mLogging;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> mTraceTag;</span><br></pre></td></tr></table></figure>
<p>其中sThreadLocal我们已经不陌生了，用来保存不同线程的Looper对象；sMainLooper是主线程的looper，这个比较特殊。sObserver是用来处理事务的观察者（暂且不管）。mQueue用来保存消息队列，mThread是当前工作线程。mInLoop标记looper正在工作当中。mLogging是日志工具。</p>
<p>前面已经提到，每一个线程必须先构造looper，消息机制才能正常工作。那么我们就来看一看Looper的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里就是简单地构造了looper对应的消息队列，并保存了当前的线程对象。值得注意的是，这个唯一的构造方法是私有的，说明我们不能直接通过new获取一个looper。相反，我们需要调用prepare()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在prepare方法中，我们会先尝试从threadLocal中获取looper，看看当前线程是否已经有looper了。如果有，将会抛出异常，以此保证每个线程只能持有最多一个looper对象。如果没有，就会构造looper并放入threadLocal中。</p>
<p>前面我们反复提到了主线程looper的特殊性。实际上，Looper类还提供了一个prepareMainLooper()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        prepare(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">这个方法原本用于让ActivityThread创建主线程looper，但现在安卓环境会自己帮你创建，于是这个方法就被废弃了。现在，我们只需要知道主线程looper是系统自身已经创建好的，不需要自己再调用prepare方法创建。</span><br><span class="line">下面我们开始介绍loop()方法。只有调用了loop()，消息循环才能真正起作用。</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me.mInLoop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">                SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                        + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">slowDeliveryDetected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">            <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.<span class="keyword">when</span> &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.<span class="keyword">when</span>) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.<span class="keyword">when</span>, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```java</span><br><span class="line">提取出核心代码，其实loop的工作非常简单：</span><br><span class="line">```java</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(;;)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>就是无限循环地调用mq的next()方法，直到mq退出返回Null。什么时候mq返回null呢？当looper调用quit方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">        mQueue.quit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">会接着调用mq的quit:</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">(<span class="type">boolean</span> safe)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">这里将消息队列的mQuitting设置为了<span class="literal">true</span>。再看next()中的一段代码：</span><br><span class="line">```java</span><br><span class="line">    <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，looper调用quit时，mq就会退出。消息循环终止。<br>现在，我们有了looper，当Looper从mq中取出了一条消息时，就会对其进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">```    </span><br><span class="line">其中，msg.target就是发送这条消息的对象。也就是说，当我们使用handler发送一条消息后，这条消息经过放入mq，再被looper取出，又被looper分发给了同一个handler。只不过handler对象虽然是同一个，发送和接收消息时所处的线程却不一定相同。下面我们一探handler的dispatchMessage()方法：</span><br><span class="line"></span><br><span class="line"># Handler的工作原理</span><br><span class="line">如何使用handler发送消息，已经在介绍MQ时说过了。我们主要看一看handler是如何处理Looper取出的消息的：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先会检查消息中的callback是否为空，这里callback就是通过post方式提交的runnable对象。如果不为空，进一步调用handleCallback()方法，这个方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br><span class="line">```    </span><br><span class="line">就是执行runnable的run方法，完成其中的任务。</span><br><span class="line">如果callback为空，会接着检查mCallback是否为空。前面我们已经介绍过，mCallback是handler内部定义的一个接口，提供了另一种使用Handler的方式：<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Callback)，这时就会按照callback内部的处理逻辑（自己在创建时实现）来处理方法。最后，如果mCallback为空，说明处理的是普通的message。调用handleMessage(必须在创建handler时重写，默认是一个空的方法)来处理即可。</span><br><span class="line">这样，我们就大致搞清楚了handler消息机制的主要工作原理，即handler,mq,looper三大件各自的作用及使用方法。handler使用简单，快捷，但也存在一个一直为人诟病的潜在问题：**内存泄露**。下面我们就来探讨handler引发内存泄露的问题和常用的解决方案。</span><br><span class="line"># Handler内存泄漏</span><br><span class="line">众所周知在java中，成员对象会默认隐式地持有外部类的对象。假设现在我们在MainActivity中创建了一个handler对象，那么这个handler也就持有了MainActivity的引用。现在考虑这样一种情况：如果向handler提交了一组任务，当handler还在处理任务的时候退出MainActivity会怎么样？</span><br><span class="line">正常来说，MainActivity应该被回收并释放。但由于此时handler仍在处理正在进行的任务而存在，其持有MainActivity的引用，导致gc无法及时对MainActivity进行回收。如此一来，便发生了内存泄露。</span><br><span class="line">通常情况下，handler的内存泄露都是暂时的，当其中的任务全部处理完毕时，内存还是会得到释放。但有问题就应该解决，以防止更大的问题产生。如何规避这种情况呢？</span><br><span class="line">首先我们可以想到，将handler加上<span class="keyword">static</span>修饰，**变成静态内部类**，这样handler就不会再隐式持有activity的引用了。但是这样，就又产生了一个问题：静态的handler无法访问activity实例，如果要用到activity的资源怎么办？</span><br><span class="line">方法很简单，让handler持有外部activity的**弱引用**不就好了？弱引用会在遇到gc时被回收，这样就基本上解决了问题。</span><br><span class="line">最后，我们上一个演示实例。假设现在有这样一个需求：进入app时展示欢迎界面，一段时间后跳转至另一界面。一个简单的实现是准备两个activity，用handler实现定时intent跳转。</span><br><span class="line">我们采用自定义handler的方式：</span><br><span class="line">```java</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        WeakReference&lt;WelcomeActivity&gt; mactivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, WelcomeActivity activity)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);<span class="comment">//调用父类的显式指明的构造函数</span></span><br><span class="line">            mactivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;WelcomeActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="type">WelcomeActivity</span> <span class="variable">nactivity</span> <span class="operator">=</span> mactivity.get();</span><br><span class="line">            <span class="keyword">if</span>(nactivity == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(mactivity.get(), LoginActivity.class);</span><br><span class="line">                    mactivity.get().startActivity(intent);</span><br><span class="line">                    mactivity.get().finish();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我这里就采用了static和weakReference来避免内存泄露和引用activity。创建handler实例后，在activity的onCreate()中调用handler.sendEmptyMessageDelayed(0,3000);即可实现功能。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>handler消息机制是android开发重要的功能，需要我们清楚其原理和实现。<br>这是我第一次尝试自主分析源码，因此文章中可能存在错误，以及一些理解不够深入。欢迎大佬提出问题并指正！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>《CSAPP》—— Data Lab</title>
    <url>/2025/09/01/old-data-lab/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2022年4月30日。</strong></p>
<p>话说从寒假开始半摸半读《CS:APP》，但是一直没有写Lab。都说9个Lab是全书的精华，因此深感有必要做一下，所以前阵子抽空先把DataLab做了。虽说是第一个（<del>据说也是最简单的</del>）Lab，却也做的磕磕绊绊，深感自己码力不足。总之最后是完成了，还是写篇博客记录一下，也方便自己日后review。</p>
<h3 id="1分题"><a href="#1分题" class="headerlink" title="1分题"></a>1分题</h3><p>1分题基本都是签到题，难度不大。</p>
<h5 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x&amp;y)&amp;~(x&amp;~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只使用位与和位非实现位或，运用<strong>De Morgan’s laws</strong>就行了。</p>
<h5 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回补码表示的最小数，即0x8000_8000，也即<code>int</code>类型能表示的最小数，也没有什么好说的。</p>
<h3 id="2分题"><a href="#2分题" class="headerlink" title="2分题"></a>2分题</h3><p>开始有些技巧性的操作出现了。</p>
<h5 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = x + <span class="number">1</span>; <span class="comment">// Tmin,1000...</span></span><br><span class="line">  x = x + i; <span class="comment">// -1,1111...</span></span><br><span class="line">  x = ~x; <span class="comment">// 0,0000...</span></span><br><span class="line">  i = !i; <span class="comment">// exclude x=0xffff...</span></span><br><span class="line">  x = x + i; <span class="comment">// exclude x=0xffff...</span></span><br><span class="line">  <span class="keyword">return</span> !x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求如果x是补码表示的最大数就返回1，否则返回0。<br>那么我们首先要能识别出补码最大数，并且能将其转化为0x1作为结果。显然0x7fff_ffff就是补码最大数，如何利用允许使用的运算符将其转化为0x1呢？这里就比较tricky了。我们可以取x + 1 + x，如果x是0x7fff_ffff时，将得到0xffff_ffff，即全1。对全1取位反即可得到0，再对0取逻辑非就能得到0x1了。<br>但这里有一个容易忽略的情形，即当x为0xffff_ffff时，由于溢出，x + 1 + x也能得到同样的结果（我是在btest时才发现这个特例），所以需要排除这个情形，使得<strong>只有当x&#x3D;0x7fff_ffff时才能返回0x1</strong>。为此，我们可以不着急对0取逻辑非，而是先再对原来的x+1取逻辑非，再加给取位反后的x + 1 + x。当x为0x7fff_ffff时，这一步多出的操作不会对结果造成任何影响，因为此时x + 1取非后得到的是0，加个0显然不会有影响；但对于x为0xffff_ffff时，x + 1取非后得到的是1，加回去后得到1，再取逻辑非时就变成了0，从而排除了这个例外。</p>
<h5 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0xAA</span> + (<span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  mask = mask + (mask &lt;&lt; <span class="number">16</span>); <span class="comment">// mask = 0xAAAAAAAA</span></span><br><span class="line">  x = mask &amp; x;</span><br><span class="line">  <span class="keyword">return</span> !(~x &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从0开始计位，若x所有奇数位都为1则返回1，否则返回0。<br>如何提取x的奇数位呢？显然用一个奇数位为1，偶数位为0的mask就行了，但我们不能直接用<code>int mask = 0xAAAAAAAA</code>构造出这个掩码，因为Lab要求整数实验的代码最多使用8位常数，如0xAA，所以我们首先要用0xAA产生0xAAAAAAAA，方法有很多，这里就不再赘述。再用这个mask与x位与，即可在结果的奇数位上对应得到x的奇数位。如何判定x的奇数位是否全为1呢？我们很容易想到如果如此，那么x位反后再与mask位与，应当得到全0，因为一个是奇数位全0，偶数位全1，另一个是奇数位全1，偶数位全0，没有一位是相等的。再对结果取逻辑非就能得到1。而对于不满足的x，检验可知经同样的运算，最终都会得到0。</p>
<h5 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回x的相反数。只要对补码表示有基本了解，这题应该都是秒过，不再赘述。</p>
<h3 id="3分题"><a href="#3分题" class="headerlink" title="3分题"></a>3分题</h3><p>难度更大了。。。</p>
<h5 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 考察如何使用位运算比较大小-&gt;不能直接用算术运算符，但思路依然是可以比较符号位-&gt;用位运算凑出符号位改变的临界数</span></span><br><span class="line">  <span class="type">int</span> sign = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> compH = ~(sign | <span class="number">0x39</span>); <span class="comment">// 当与小于等于0x39的数相加后，符号位为0；当与大于0x39的数相加后，符号位变为1</span></span><br><span class="line">  <span class="type">int</span> compL = ~<span class="number">0x30</span>; <span class="comment">// 当与大于0x30的数相加后，符号位为0；当与小于等于0x30的数相加后，符号位变为1</span></span><br><span class="line">  <span class="type">int</span> sign_1 = ((compH + x) &amp; sign) &gt;&gt; <span class="number">31</span>; <span class="comment">// 当符号位为0时，得到sign_1为全0；当符号位为1时，得到sign_1为全1</span></span><br><span class="line">  <span class="type">int</span> sign_2 = ((compL + x + <span class="number">0x1</span>) &amp; sign) &gt;&gt; <span class="number">31</span>; <span class="comment">// 这里需要额外加个1，因为当x=0x30时，符号位仍为1，需要加1进位使其变为0.且加1不会对0x30之后的数的结果产生影响</span></span><br><span class="line">  <span class="keyword">return</span> !(sign_1 | sign_2); <span class="comment">// 这里要用逻辑非来实现或非，因为最后要求的是返回0/1，而sign_1/2位或后仍是32位全0/1整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若x是0~9数字的ASCII码表示，则返回1，否则返回0。<br>只要我们能比较x同0x30和0x39的大小就行了。如何用位运算比较两个数之间的大小呢？（<del>我不道啊？看了别人的写法才懂</del>）有一种比较tricky的处理方式，虽然这题不给用减法，但我们可以借鉴类似的想法，即自己构造出会使得符号位改变的临界数，再看符号位就行了。具体思路可以看代码注释。</p>
<h5 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> flag = !!x;</span><br><span class="line">  <span class="type">int</span> mask = ~flag + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (y &amp; mask) + (z &amp; ~mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的难点在于如何从x的位级表示获取其一位布尔值，使用逻辑非即可。第一次逻辑非会把0转化为1，非0转化为0，第二次逻辑非会还原为原逻辑值，所以<strong>需要2次逻辑非</strong>。但我们不能直接用这个一位布尔值，因为要实现选择操作，用一位只能保留原输入的一位，显然是不对的，故还需经一步得到全1和全0，再做与操作。</p>
<h5 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sign = <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sign_x = x &amp; sign;</span><br><span class="line">  <span class="type">int</span> sign_y = y &amp; sign;</span><br><span class="line">  <span class="type">int</span> sign_inequal = ((sign_x ^ sign_y) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>; <span class="comment">// sign_inequal为0x1，表示符号不同；为0则表示符号相同</span></span><br><span class="line">  <span class="type">int</span> sign_diff = (y + ~x + <span class="number">0x1</span>) &amp; sign; <span class="comment">// y - x 的差值符号，当为0x1&lt;&lt;32时表示y&lt;x，当为全0时表示y&gt;=x。 有错误：当x为负，y为正时有可能溢出，因而不可靠。只有当符号相同时才可靠</span></span><br><span class="line">  <span class="type">int</span> same_res = !sign_diff;<span class="comment">// 符号相同时的结果</span></span><br><span class="line">  <span class="type">int</span> diff_res = !sign_y;<span class="comment">//符号不同时的结果，当y为正数时返回值就为1，否则返回0</span></span><br><span class="line">  <span class="keyword">return</span> (sign_inequal &amp; diff_res) + (!sign_inequal &amp; same_res);<span class="comment">//符号不同时，即sign_equal为1时，返回diff_res；否则返回same_res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较x,y大小，返回比较结果。<br>第一眼看，我们也许会想用isAsciiDigit的思路做这题，但这是不行的。因为上一题我们只考虑0x30~0x39这一正数小区间，而现在我们需要考虑整个实数域。用相同的方法处理y为负数时会出现问题。<br>这时就要回退到一般运算思路，即符号不同正数为大，符号相同看差值符号即可。获取差值时，这里不能直接用’-‘，故用补码方式。<br>x,y和y-x的符号不难获得，但难点在于如何通过位运算在符号不同时正确选择正的那一个数，思路可参见代码注释。</p>
<h3 id="4分题"><a href="#4分题" class="headerlink" title="4分题"></a>4分题</h3><p>这几位更是重量级。</p>
<h5 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑非运算符。要做出这题，首先需要清楚C语言中的右移对于有符号数是算术右移，以及整数中的1000…0000表示最小数而不是表示负零。其次，还是要想办法将位级表示的x的信息用一个比特表示出来，之前我们都是用!!，但这题就是需要我们实现!，故得采取新的思路。想到对于0来说，其原码和补码都是0x0000，符号位相或仍为0；而对于非0数，其源码和补码的符号位必然互补，从而相或时为1，进而就可以区分0和非0数了。最终要求是求反，故再加1即可。<br>真正实现起来，一行代码即可搞定，但背后的思考过程不是那么容易，你得想到0和非0数各自相反数符号位的差异，才能做出这题。</p>
<h5 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0; <span class="comment">// 必须提前声明，否则dlc检查时会报错</span></span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>; <span class="comment">// 提取符号位，sign为全1或全0</span></span><br><span class="line">  x = (sign &amp; ~x) | (~sign &amp; x); <span class="comment">// 这一步是为了方便处理负数。对负数取反，将找0转化为找1，这样对于正负数就可以统一处理了</span></span><br><span class="line">  <span class="comment">//经上一行操作后，x符号位总为0，故算术右移不会造成影响</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; <span class="comment">//考察高16位是否有1，若有，b16得16，否则得0，至少需要16位。</span></span><br><span class="line">  x = x &gt;&gt; b16; <span class="comment">//若高16位有1，则将x右移16位。对于b16=16，此为向左缩小搜索范围；对于b16=0，此为向右增大搜索范围</span></span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">//考察高8位是否有1，若有，b16得8，否则得0，至少需要位数再加8位</span></span><br><span class="line">  x = x &gt;&gt; b8; <span class="comment">//继续缩小范围，考察高4位。下面以此类推。</span></span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  b0 = x &gt;&gt; b1; <span class="comment">// 最高两位是11时，所需位数还得加1</span></span><br><span class="line">  <span class="keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="number">1</span>; <span class="comment">// 符号位必定占一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求用补码表示x至少需要几位。思路很好想，符号位必定占一位，剩下的从左往右找第一个有效位(正数是1，负数是0)，其与之后剩下的位都是需要的位。但是代码实在写不出来，就copy别人的代码了。<br>实际上代码的思路也很简单，就是在这串32位比特上做<strong>二分搜索</strong>（<del>还能这样，艹</del>），找到第一个有效位,同时统计比特数量。<br>这里还有一个小插曲，即使用的临时变量都必须在函数的一开始提前声明，不能在使用时才声明并初始化，否则dlc检查时会报错，说你没有声明变量。不太清楚原因。</p>
<h5 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>; <span class="comment">//exp低23位表示原数的阶码</span></span><br><span class="line">  <span class="type">int</span> sign = uf &amp; <span class="number">0x80000000</span>; <span class="comment">// sign最高位为原数符号位，其余位全为0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> uf; <span class="comment">// 无穷或NaN</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) <span class="keyword">return</span> sign | (uf &lt;&lt; <span class="number">1</span>); <span class="comment">// 非规格数</span></span><br><span class="line">  <span class="keyword">if</span> (++<span class="built_in">exp</span> == <span class="number">255</span>) <span class="keyword">return</span> sign | <span class="number">0x7f800000</span>; <span class="comment">// 溢出，返回无穷大</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | (uf &amp; <span class="number">0x807fffff</span>); <span class="comment">// 规格数且无溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现2*f。与前面的题相比，这题其实不难，只要认真读了书，知道浮点数的表示方法就能做出来。<br>若为规格数，直接阶码加1即可。但若阶码加1后变为全1，则返回的应是对应符号的无穷大。<br>若为非规格数，则直接左移1位并补上符号位即可。这是因为当非规格数的小数字段最高位为0时，直接左移1位仍表示为非规格数，且小数字段因左移而乘以2，自然得到了结果<br>当小数字段最高位为1时，左移1位会导致阶码变为0x1而成为规格数。但对规格数而言，0x1阶码与非规格数表示的指数相同，都为1-Bias。且虽然小数最高位看似丢失了，但规格数表示的尾数本身就是1+f，与非规格数的尾数f相比，相当于把最高位的1表示成十进制的0.5乘以2得到的1单独提取了出来，其余位左移自然乘以2。得益于IEEE浮点标准的这种非规格数平滑向规格数过渡的设计，我们这里处理非规格数也简单很多，不需要担心溢出。<br>若为无穷大和NaN，直接返回原数即可</p>
<h5 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span>, E, tail, sign;</span><br><span class="line">  <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当uf为0，-0时，直接返回0即可。注意这个-0容易遗漏</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  sign = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  tail = (uf &amp; <span class="number">0x007fffff</span>) | <span class="number">0x00800000</span>; <span class="comment">// 由于之后的代码会排除非规格数，故对规格数而言，真实的小数表示为尾数+1，这里与0x00800000相或就是为了加上小数点前的1</span></span><br><span class="line"></span><br><span class="line">  E = <span class="built_in">exp</span> - <span class="number">127</span>; <span class="comment">// E表示由阶码复原得到的真实指数，注意E &gt; 31时，必定在左移时覆盖掉符号位，所以会溢出。此时也包括了NaN和INF（E=255-127必然大于31）</span></span><br><span class="line">  <span class="keyword">if</span> (E &gt; <span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">if</span> (E &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 直观来理解，对于始终小于2的尾数，当E &lt; 0时，相当于至少除以2，所得一定是个小于1的小数，故取0。非规格数也在这里被排除</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0 &lt;= E &lt;= 31时，依然有可能发生溢出，故需要做甄别并排除</span></span><br><span class="line">  <span class="comment">// 开始左移/右移。当E &gt; 23时，说明乘法后所有小数点后的原尾数位都移到了小数点前，此时结果为一个整数，故直接左移即可。 当E &lt; 23时， 说明乘法后仍含有小数部分，</span></span><br><span class="line">  <span class="comment">// 则转为Int时直接丢弃这些小数部分即可，对应的操作就是右移</span></span><br><span class="line">  tail = (E &gt; <span class="number">23</span>) ? tail &lt;&lt; (E - <span class="number">23</span>) : tail &gt;&gt; (<span class="number">23</span> - E);</span><br><span class="line">  <span class="comment">// 原来是按位表示的1+小数，故对E&gt;23来说，一开始乘2时会先移动小数点，故不会改变作为Int的各位数值。只有当超过23部分的E会导致数值开始乘2，即左移</span></span><br><span class="line">  <span class="comment">// 而对于E&lt;23来说，无论如何都只会改变小数点而不改变数值，因而不会左移。但因为此时含有小数，故权值不是从0而是从某个负数开始，因而各位上的权值对应都会衰减，本应是右移23位来对上小数</span></span><br><span class="line">  <span class="comment">// 的权值，但因为有乘E次2的操作，每次乘2都会使权值对应升高1位，故会抵消E次右移操作，最终效果就是右移23-E位。同时在右移的过程中，还舍去了小数的信息。</span></span><br><span class="line">  <span class="comment">// 统一的解释：因为小数从左向右的权值是从-1开始的，而不是从0开始的，故对于原小数的位级表示，应首先右移23位来对上正确的权值(&lt;&lt;-23 or &gt;&gt;23)。</span></span><br><span class="line">  <span class="comment">// 但因为有乘E次2的操作，每次乘2都会使权值对应升高1位，故会抵消E次右移操作，最终效果就是右移23-E位(&lt;&lt;E-23 or &gt;&gt; 23-E)。同时注意在右移的过程中，还会舍去小数的信息。</span></span><br><span class="line">  <span class="keyword">return</span> sign ? -tail : tail; <span class="comment">// 保留原符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<code>float</code>到<code>int</code>强制类型转换。这题也没写出来，copy了网上代码，代码解释看注释就行。</p>
<h5 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>; <span class="comment">// 加上bias得到位级表示的阶码</span></span><br><span class="line">  <span class="comment">// 阶码的范围是00000000~11111111，超出这个表示范围时，对应0(全0)和INF(0111_1111_1000_0...0)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 极小数，当做0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &gt; <span class="number">0xff</span>) <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// INF </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现2的幂次方运算。这题简单一点，首先由x加上bias得到对应浮点数的阶码。由于2的幂符号位为0，尾数也为全0，故再对阶码移位到浮点数对应的位置即可。注意要排除极小数和无穷，即超过阶码表示的数。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这里有个小插曲，编译btest时提示不兼容的gcc。这是因为我的机器是x86-64，但Lab的makefile中添加了-m32参数，而我缺少在64位机器编译32位程序的库。这里可以选择修改makefile，把这个参数删去或者改为-m64，或者安装需要的库，有<strong>gcc-multilib</strong>和<strong>module-assistant</strong>。<br>测试结果如图。<br><img src="https://s2.loli.net/2022/04/30/JahmHNLkZU2b8AY.png" alt="lab_1_result.png"></p>
<h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>从这个学期开始，我一直处于一种浑浑噩噩的状态，课内没学好，加权卷不上去，课外的知识也进度缓慢（包括但不限于CSAPP只读到了第四章，计算机视觉半熟不熟，几个月没写安卓）。最近看了许多大牛学长的博客和他们的经历分享，收获了很多，还是希望能向强者靠拢。开始做CSAPP的lab，也算是自己挣脱摆烂状态的一次尝试。希望自己能继续努力，保持学习吧！</p>
]]></content>
      <categories>
        <category>CSAPP</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>C</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Scope Function 速记速查</title>
    <url>/2025/09/02/old-scope-function/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2021年11月29日。</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>kotlin是一款十分灵活而又强大的语言。合理地运用kotlin的一些特性，可以极大地提高代码可读性和质量，提高效率。下面我们就来说一说kotlin中的<strong>scope function</strong>。</p>
<h1 id="域函数"><a href="#域函数" class="headerlink" title="域函数"></a>域函数</h1><p>我们主要介绍<strong>let, also, with, run, apply</strong>这五种常用的域函数。</p>
<h3 id="1-let"><a href="#1-let" class="headerlink" title="(1)let"></a>(1)let</h3><p>先上let函数的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码我们可以看出，首先，let是对调用者的扩展函数。其次，let函数接收一个lambda表达式block作为唯一参数，且将调用者本身作为参数传给了lambda。而在函数的内部，首先使用contract进行约束，向编译器表明这个lambda只会执行一次（EXACTLY_ONCE），接着就是调用lambda并返回其返回值。<br>进而，我们可以得出如下结论：</p>
<ol>
<li>由于let函数将调用者作为lambda的参数，因而在let闭包内，可以用<strong>it</strong>指代调用者；</li>
<li>let函数是具有返回值的，且其返回值应为lambda表达式中的最后一行&#x2F;return语句。</li>
</ol>
<p>随之，我们可以得到let函数的作用：</p>
<ol>
<li>在明确某一对象实例在一定范围内需要使用时，可以对其调用let，再用it指代；</li>
<li>（常用）对某一可能为空的对象进行统一判空的处理。</li>
</ol>
<p>这里对作用二作一些解释。对于一个可能为空的对象object，如果不使用let，每次调用其方法或属性时，都要加上?或者!!，以及类似if not null的判空逻辑。但如果使用let，代码就将简化为如下的形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span>?.let &#123;</span><br><span class="line">    it.doSomething()</span><br><span class="line">    it.id = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码表示，只有当object不为空时，才会执行let中的逻辑，且由于判空交给了object后的?符来处理，let内部不再需要任何多余的判空。如此以来，判空就变得优雅了许多。</p>
<h3 id="2-also"><a href="#2-also" class="headerlink" title="(2)also"></a>(2)also</h3><p>先上also函数的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可见，also函数的实现思路与let类似，都是对调用者的扩展，都是将调用者作为参数传给lambda，都使用contract进行调用约束，都会在内部执行lambda。但有如下不同：lambda没有返回值，而从return语句看，also返回的是调用者本身。<br>进而，我们可以得出如下结论：</p>
<ol>
<li>also函数的应用场景与let相同；</li>
<li>also函数返回值为调用者本身。</li>
</ol>
<h3 id="3-with"><a href="#3-with" class="headerlink" title="(3)with"></a>(3)with</h3><p>先上with函数的源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然源码的整体风格和之前两者类似，但其使用方法却截然不同。首先，with是一个通用的扩展函数，其有两个参数：receiver，和一个lambda。注意这里lambda的参数是T.()，它表明将这个lambda函数作为同为类型T的receiver的一个扩展函数，从而能被receiver所调用。进而，我们可以得出如下结论：</p>
<ol>
<li>由于with内部是通过扩展函数使得receiver去调用lambda，因而可以在lambda的闭包内部直接访问receiver的public方法&#x2F;属性。（即没有it等间接指代值）</li>
<li>with函数是具有返回值的。从源码的return语句可以看出，其返回的是lambda表达式的最后一行&#x2F;return语句。</li>
</ol>
<p>随之，我们可以得到with函数的作用：<br>在需要多次调用某一对象的方法或属性时，可以将该对象传给with，再在with内部处理相应逻辑。这样写可以避免多次重复地写该对象。<br>举个栗子：当我们想写一个alertDialog时，需要先创建builder，对builder进行一系列配置，再调用builder的create()方法返回一条alertDialog。有了with后，我们可以这样写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> alertDialog: AlertDialog</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> builder = AlertDialog.Builder(activity)</span><br><span class="line">alertDialog = with (builder) &#123;</span><br><span class="line">    <span class="keyword">val</span> alertView = layoutInflater.inflate(R.layout.dialog_confirm, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">    setView(alertView)</span><br><span class="line">    setNegativeButton(<span class="string">&quot;取消&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line">        Toast.makeText(activity, <span class="string">&quot;已取消&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    setPositiveButton(<span class="string">&quot;确定&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line">        run &#123;</span><br><span class="line">            bill?.let &#123; it1 -&gt; viewModel.deleteBill(it1) &#125;</span><br><span class="line">            activity?.onBackPressed()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是简洁了许多？</p>
<h3 id="4-run"><a href="#4-run" class="headerlink" title="(4)run"></a>(4)run</h3><p>还是先上源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run有点类似let和with的结合体，继承了两者各自的优点，因而使用场景十分广泛：首先，它像let一样是对调用者的扩展，因而可以<strong>统一判空处理</strong>；其次，它又像with一样，传入lambda的是T.()，表明它可以像with一样<strong>在闭包内直接访问方法&#x2F;属性</strong>。最后，它返回的是lambda的返回值。</p>
<h3 id="5-apply"><a href="#5-apply" class="headerlink" title="(5)apply"></a>(5)apply</h3><p>上源码。。。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，apply和run类似于also和let的关系，使用场景类似，只是返回值有差异。<br>而由于apply返回的是调用者本身，因而它十分适合用来做变量的初始化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">特点</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">let</td>
<td align="center">1.在指定域内定义变量it 2.返回最后一行</td>
<td align="center">统一判空处理</td>
</tr>
<tr>
<td align="center">also</td>
<td align="center">1.在指定域内定义变量it 2.返回传入对象本身</td>
<td align="center">统一判空处理</td>
</tr>
<tr>
<td align="center">with</td>
<td align="center">1.直接访问方法和属性 2.返回最后一行</td>
<td align="center">多次调用时省去变量名</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">1.let和with的结合 2.返回最后一行</td>
<td align="center">统一判空的同时省去it，省去变量名的同时判空</td>
</tr>
<tr>
<td align="center">apply</td>
<td align="center">1.同run 2.返回传入对象本身</td>
<td align="center">同run，此外适用于初始化变量</td>
</tr>
</tbody></table>
<p>作者纯kotlin小白，如有疏漏与错误，敬请大佬指正！</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>域函数</tag>
      </tags>
  </entry>
  <entry>
    <title>奇妙的 Sealed</title>
    <url>/2025/09/03/old-sealed-class/</url>
    <content><![CDATA[<p><strong>该篇内容为原博客博文，原上传于2023年1月18日。</strong></p>
<p><strong>Sealed Class</strong>和<strong>Sealed Interface</strong>是 kotlin 引入的全新特性。在初学 kotlin 时，我就一直没有掌握其用法，甚至到现在也不能在该用的时候立刻想到。</p>
<p>本篇文章主要总结<strong>Sealed Class</strong>的基本概念和常见用法。</p>
<h3 id="什么是-Sealed"><a href="#什么是-Sealed" class="headerlink" title="什么是 Sealed"></a>什么是 Sealed</h3><p>jetbrains 对 Sealed Class&#x2F;Interface 的介绍如下：</p>
<blockquote>
<p>Sealed classes and interfaces represent restricted class hierarchies that provide more control over inheritance. All direct subclasses of a sealed class are known at compile time. No other subclasses may appear outside a module within which the sealed class is defined. For example, third-party clients can’t extend your sealed class in their code. Thus, each instance of a sealed class has a type from a limited set that is known when this class is compiled.</p>
<p>The same works for sealed interfaces and their implementations: once a module with a sealed interface is compiled, no new implementations can appear.</p>
<p>In some sense, sealed classes are similar to enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances, each with its own state.</p>
</blockquote>
<p>从以上介绍可以大致总结出 Sealed Class&#x2F;Interface 有如下特性：</p>
<ul>
<li><p>表示受限的类层次结构，并可以对继承提供更多的控制</p>
</li>
<li><p>密封类的子类在编译期即被确定为一个有限的集合内，不可扩展</p>
</li>
<li><p>密封类的子类只能位于定义了该密封类的<strong>包</strong>中</p>
</li>
<li><p>密封类的子类可以有多个实例</p>
</li>
</ul>
<p>介绍中还提到，sealed class 和 enum class 在某种意义上是类似的，实际上，sealed class 诞生的重要原因之一正是为了克服 enum class 在某些场合下的局限性，也即上述特性的第一点和第四点。我们知道，枚举类有两个特性，在某些场合下是优点，但在另外一些场合下却可能成为缺点：</p>
<ul>
<li><p>每个枚举类型只能有一个实例（称为枚举常量）</p>
</li>
<li><p>各枚举常量只能使用相同类型的属性</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Drink</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    Milk(<span class="number">1</span>),</span><br><span class="line">    Coffee(<span class="number">2</span>),</span><br><span class="line">    Water(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在如上我们创建的枚举类中，各子类（Milk，Coffee，Water）无论有多少对象，都只能有一个实例（即单例的枚举常量），且其属性均只能为枚举类中定义的 Int 类型。</p>
<p>而密封类则取消了以上限制，允许密封类的子类具有多个实例，且各子类可以定义自己的属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    <span class="comment">// 这里直接在定义块内定义子类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Milk</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>): Drink()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Coffee</span>(<span class="keyword">val</span> id: <span class="built_in">Double</span>): Drink()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Water</span>(<span class="keyword">val</span> id: String): Drink()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，密封类允许各子类具有不同类型的属性，只需要在子类的主构造函数中声明即可。需要注意的是，密封类在继承上的写法与抽象类区别较大，反而更加类似于一般的抽象类。实际上，密封类正是抽象的，不能直接生成实例，且可以具有抽象成员。因此，密封类可以像上述写法一样定义继承自密封类的子类，也可以用<code>object</code>直接定义子类对象，也可以再用<code>sealed class</code>，即密封类继承密封类，实现更加细粒度的类层次结构。</p>
<p>各子类允许有多个不同状态的实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> milk1 = Drink.Milk(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> milk2 = Drink.Milk(<span class="number">2</span>)</span><br><span class="line">println(milk1.id)</span><br><span class="line">println(milk2.id)</span><br></pre></td></tr></table></figure>

<p>上述特性的第二点意义在于，密封类对运行时的扩展是封闭的。程序在编译时，即可通过继承关系确认密封类的全部子类，由此产生了密封类一个非常实用的用处，在写 when 语句时不需要添加 else 分支，因为全部可能的分支在编译时即可确定，没有其他情况：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(drink: <span class="type">Drink</span>)</span></span> = <span class="keyword">when</span> (drink) &#123;</span><br><span class="line">    <span class="keyword">is</span> Drink.Milk -&gt; println(<span class="string">&quot;milk&quot;</span>)</span><br><span class="line">    <span class="keyword">is</span> Drink.Coffee -&gt; println(<span class="string">&quot;coffee&quot;</span>)</span><br><span class="line">    <span class="keyword">is</span> Drink.Water -&gt; println(<span class="string">&quot;water&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述特性的第三点意义在于，限制了密封类的作用空间，并且随着 kotlin 版本的更迭越来越宽松：从只能在 sealed class 内，到 1.1 支持同一文件内，到 1.5 支持同一包下。</p>
<h3 id="怎么用-Sealed"><a href="#怎么用-Sealed" class="headerlink" title="怎么用 Sealed"></a>怎么用 Sealed</h3><p>kotlin 初学者往往会把<code>sealed class</code>当做<code>enum class</code>用，但<code>enum class</code>具有很明显的适用场景，这么做是不合适的。比如，你仅需要一系列相同类型的单例，且不需要任何额外描述，也不需要特殊的函数，那么用枚举就足够了，比如在我的《设计模式之状态模式》中，各状态有统一的处理方法，用枚举来表示。</p>
<p>在 Android 开发中， <code>sealed class</code>有如下一些使用场景：</p>
<ul>
<li><p>列表有不同类型的子项（文字、图片），用密封类表示列表的 item</p>
</li>
<li><p>封装网络请求中成功（含有任意类型的请求数据）和失败（含有失败信息，如异常）返回的数据</p>
</li>
<li><p>使用<code>object</code>达到与枚举类似的效果（虽然在 google 的官方示例都出现了这种用法，但还是不推荐。为什么不直接用枚举呢？）</p>
</li>
<li><p>其他一切不满足枚举的应用场景，但需要与枚举类似效果，可以考虑用密封类</p>
</li>
</ul>
<h3 id="关于-Sealed-Interface"><a href="#关于-Sealed-Interface" class="headerlink" title="关于 Sealed Interface"></a>关于 Sealed Interface</h3><p>以上都在讨论<code>sealed class</code>，而<code>sealed interface</code>作为 kotlin1.5 中登场的新特性，也值得说道说道。</p>
<p>密封接口进一步补足了密封类和枚举类的一些不足之处，如枚举类编译后继承自<code>Enum</code>，由于单继承不能再继承其他类，此时可以用密封接口，对枚举类做进一步划分。当然直接用嵌套密封类也未尝不可。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Sealed Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 中的 &#39;[]&#39;</title>
    <url>/2025/09/08/index_in_kotlin/</url>
    <content><![CDATA[<h2 id="Kotlin-的-到底是什么"><a href="#Kotlin-的-到底是什么" class="headerlink" title="Kotlin 的 [] 到底是什么"></a>Kotlin 的 <code>[]</code> 到底是什么</h2><p>刚写 Kotlin 时，我就很快爱上了 <code>map[&quot;key&quot;]</code>、<code>list[i]</code> 这种简洁的 <code>[]</code> 写法。它看起来就像在其他语言中早已熟悉的“下标访问”，但更准确的说法是：<strong><code>[]</code> 是编译器提供的运算符约定（operator convention）语法糖</strong>。它既能访问 List&#x2F;Array，也能用于 Map，甚至可以被自定义到任何类型上。</p>
<hr>
<h2 id="1-的原理：编译期改写为-get-set"><a href="#1-的原理：编译期改写为-get-set" class="headerlink" title="1) [] 的原理：编译期改写为 get/set"></a>1) <code>[]</code> 的原理：编译期改写为 <code>get/set</code></h2><p>Kotlin 的 <code>[]</code> 并不是某种“运行时特性”。编译器会把它<strong>静态地改写</strong>成函数调用：</p>
<ul>
<li>读取：<code>a[b]</code>  →  <code>a.get(b)</code></li>
<li>写入：<code>a[b] = c</code>  →  <code>a.set(b, c)</code></li>
</ul>
<p>只要你的类型（成员函数或扩展函数）提供了相应签名，并用 <code>operator</code> 修饰，就可以使用 <code>[]</code>。一个简单的自定义类实现例子如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grid</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span>: Array&lt;Array&lt;T&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: T = <span class="keyword">data</span>[x][y]</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, v: <span class="type">T</span>)</span></span> &#123; <span class="keyword">data</span>[x][y] = v &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">val</span> g = Grid(arrayOf(arrayOf(<span class="number">1</span>, <span class="number">2</span>), arrayOf(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">	println(g[<span class="number">1</span>, <span class="number">0</span>]) <span class="comment">// 等价于 g.get(1, 0)</span></span><br><span class="line">	g[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">9</span>      <span class="comment">// 等价于 g.set(0, 1, 9)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而细心的小伙伴可能就已注意到了：当我们在 Kotlin 中使用 <code>mutableMapOf&lt;K, V&gt;()</code> 在底层创建<code>java.util.LinkedHashMap&lt;K, V&gt;</code>时， Java 类本身并没有定义<code>set</code>方法，我们却仍可以在 Kotlin 侧直接用索引语法。这是因为其借助了 Kotlin 另一个强大的功能：<strong>扩展方法</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;@kotlin.internal.OnlyInputTypes K, V&gt;</span> Map<span class="type">&lt;out K, V&gt;</span>.<span class="title">get</span><span class="params">(key: <span class="type">K</span>)</span></span>: V? =  </span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (<span class="keyword">this</span> <span class="keyword">as</span> Map&lt;K, V&gt;).<span class="keyword">get</span>(key)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Allows to use the index operator for storing values in a mutable map. */</span><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> MutableMap<span class="type">&lt;K, V&gt;</span>.<span class="title">set</span><span class="params">(key: <span class="type">K</span>, value: <span class="type">V</span>)</span></span>: <span class="built_in">Unit</span> &#123;  </span><br><span class="line">    put(key, value)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在 Kotlin&#x2F;Java 互操作里，<strong>只要 Java 类上确实存在符合签名的 <code>get(...)</code> &#x2F; <code>set(...)</code> 实例方法，Kotlin 侧通常就可以直接用 <code>[]</code></strong>——不需要在 Java 里写什么 <code>operator</code>（Java 也没这个关键字）。Kotlin 编译器会把 <code>a[i]</code>&#x2F;<code>a[i]=v</code> 按“运算符约定”解析到这些方法上。</p>
<blockquote>
<p>关键点 </p>
</blockquote>
<ul>
<li><strong>索引参数不必一定是 Int</strong>：Map 的 key 就是泛型 <code>K</code>。</li>
<li><code>a[x, y]</code> 这种“多参数索引”是合法的，本质是 <code>get(x, y)</code>。</li>
<li>这是<strong>编译期语法糖</strong>：是否能用 <code>[]</code>，由静态类型上有没有匹配的 <code>operator get/set</code> 决定。</li>
</ul>
<hr>
<h2 id="2-Kotlin-标准集合里-的语义：Map-≠-List-Array"><a href="#2-Kotlin-标准集合里-的语义：Map-≠-List-Array" class="headerlink" title="2) Kotlin 标准集合里 [] 的语义：Map ≠ List&#x2F;Array"></a>2) Kotlin 标准集合里 <code>[]</code> 的语义：Map ≠ List&#x2F;Array</h2><p>虽然都用 <code>[]</code>，但 Map 与 List&#x2F;Array 的失败策略完全不同。这是 Kotlin 设计中很重要的语义区分，写码时也需要注意。</p>
<h3 id="2-1-Map：查询语义（缺失返回-null）"><a href="#2-1-Map：查询语义（缺失返回-null）" class="headerlink" title="2.1 Map：查询语义（缺失返回 null）"></a>2.1 Map：查询语义（缺失返回 null）</h3><p>对 <code>Map&lt;K, V&gt;</code>：</p>
<ul>
<li><code>map[key]</code> 会调用 <code>get(key)</code></li>
<li><strong>key 不存在 → 返回 <code>null</code></strong></li>
<li>因此返回类型通常是 <strong><code>V?</code></strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> m = mapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>)</span><br><span class="line">println(m[<span class="string">&quot;a&quot;</span>]) <span class="comment">// 1</span></span><br><span class="line">println(m[<span class="string">&quot;b&quot;</span>]) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>注意：即使 key 存在，value 也可能是 <code>null</code>（当 <code>V</code> 允许为 null 时）。所以 <code>null</code> 可能表示两种情况：</p>
<ol>
<li>key 不存在  </li>
<li>key 存在但 value 本来就是 null</li>
</ol>
<p>如果希望“缺 key 就直接失败（抛异常等）”，常见的处理方式是：</p>
<ul>
<li><code>map.getValue(key)</code>：缺失抛 <code>NoSuchElementException</code></li>
<li><code>requireNotNull(map[key])</code></li>
<li><code>map[key] ?: error(&quot;...&quot;)</code></li>
</ul>
<h3 id="2-2-List-Array-String：索引语义（越界抛异常）"><a href="#2-2-List-Array-String：索引语义（越界抛异常）" class="headerlink" title="2.2 List &#x2F; Array &#x2F; String：索引语义（越界抛异常）"></a>2.2 List &#x2F; Array &#x2F; String：索引语义（越界抛异常）</h3><p>对 <code>List</code>、<code>Array</code>、<code>String</code>：</p>
<ul>
<li><code>list[i]</code> &#x2F; <code>arr[i]</code> &#x2F; <code>s[i]</code> 是严格索引访问</li>
<li><strong>越界会抛异常</strong>（如 <code>IndexOutOfBoundsException</code>、<code>StringIndexOutOfBoundsException</code>）</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">println(list[<span class="number">1</span>]) <span class="comment">// 20</span></span><br><span class="line">println(list[<span class="number">2</span>]) <span class="comment">// 抛异常</span></span><br></pre></td></tr></table></figure>

<p>Kotlin也提供了更安全的替代版本：</p>
<ul>
<li><code>getOrNull(i)</code>：越界返回 <code>null</code></li>
<li><code>getOrElse(i) &#123; default &#125;</code>：越界返回默认值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(list.getOrNull(<span class="number">2</span>))         <span class="comment">// null</span></span><br><span class="line">println(list.getOrElse(<span class="number">2</span>) &#123; -<span class="number">1</span> &#125;)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Set：通常没有"><a href="#2-3-Set：通常没有" class="headerlink" title="2.3 Set：通常没有 []"></a>2.3 Set：通常没有 <code>[]</code></h3><p><code>Set</code> 不支持“按位置”或“按 key”索引，因此没有 <code>set[i]</code> 这种形式。常用的是：</p>
<ul>
<li><code>x in set</code> &#x2F; <code>set.contains(x)</code> 判断元素是否存在</li>
</ul>
<hr>
<h2 id="3-和-C-Java-Python-的-对比"><a href="#3-和-C-Java-Python-的-对比" class="headerlink" title="3) 和 C &#x2F; Java &#x2F; Python 的 [] 对比"></a>3) 和 C &#x2F; Java &#x2F; Python 的 <code>[]</code> 对比</h2><p><code>[]</code> 是一个长得很像、但在不同语言里“底层机制与语义”差别极大的符号。如果你像我一样日常需要经常在不同语言的项目间来回切换时，可能会搞混，或者直接认为 Kotlin的 <code>[]</code> 与其他语言完全是一种东西。然而他们虽为同一个符号，实际却有着不同的契约。</p>
<h3 id="3-1-Kotlin-vs-Java：Java-没有通用的-重载"><a href="#3-1-Kotlin-vs-Java：Java-没有通用的-重载" class="headerlink" title="3.1 Kotlin vs Java：Java 没有通用的 [] 重载"></a>3.1 Kotlin vs Java：Java 没有通用的 <code>[]</code> 重载</h3><p>Java 的 <code>[]</code> 只用于数组访问（和数组类型语法），例如 <code>arr[i]</code>。<br>Java <strong>不能</strong>把 <code>obj[key]</code> 解释成方法调用（没有运算符重载），所以 Java 中 Map 访问只能写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.get(key)</span><br></pre></td></tr></table></figure>

<p>而 Kotlin 的 <code>map[key]</code> 对 JVM 来说仍然只是一次 <code>get(key)</code> 方法调用，是 Kotlin 编译器提供的语法糖。</p>
<h3 id="3-2-Kotlin-vs-C：C-的-是指针算术（无边界检查）"><a href="#3-2-Kotlin-vs-C：C-的-是指针算术（无边界检查）" class="headerlink" title="3.2 Kotlin vs C：C 的 [] 是指针算术（无边界检查）"></a>3.2 Kotlin vs C：C 的 <code>[]</code> 是指针算术（无边界检查）</h3><p>C 里 <code>a[i]</code> 等价于 <code>*(a + i)</code>：</p>
<ul>
<li>越界通常是<strong>未定义行为</strong>（可能崩溃，也可能悄悄读错）</li>
<li>不存在“缺失返回 null”的统一约定</li>
</ul>
<p>而Kotlin 的 List&#x2F;Array 越界是<strong>受控失败（抛异常）</strong>，错误更可见、更可定位。</p>
<h3 id="3-3-Kotlin-vs-Python：都“像方法”，但-Kotlin-是静态的、Python-更动态"><a href="#3-3-Kotlin-vs-Python：都“像方法”，但-Kotlin-是静态的、Python-更动态" class="headerlink" title="3.3 Kotlin vs Python：都“像方法”，但 Kotlin 是静态的、Python 更动态"></a>3.3 Kotlin vs Python：都“像方法”，但 Kotlin 是静态的、Python 更动态</h3><p>Python 的：</p>
<ul>
<li><code>obj[key]</code> → <code>obj.__getitem__(key)</code></li>
<li><code>obj[key] = v</code> → <code>obj.__setitem__(key, v)</code></li>
</ul>
<p>这和 Kotlin 的“映射到方法”很相似，但差异非常关键：</p>
<ul>
<li><strong>动态 vs 静态</strong>：Python 在运行时决定调用谁；Kotlin 在编译期由静态类型解析 <code>get/set</code>。</li>
<li><strong>切片语法</strong>：Python 有内建 <code>a[1:5]</code>（slice）。<br>Kotlin <strong>没有内建切片 <code>[]</code></strong>：<code>list[1..5]</code> 默认不表示切片（除非自己定义 <code>get(IntRange)</code>）。</li>
<li><strong>负数索引</strong>：Python <code>a[-1]</code> 是最后一个元素；Kotlin <code>list[-1]</code> 会越界异常（没有特殊语义）。</li>
</ul>
<h3 id="3-4-Kotlin-vs-C-：都可重载，但容器默认行为不同"><a href="#3-4-Kotlin-vs-C-：都可重载，但容器默认行为不同" class="headerlink" title="3.4 Kotlin vs C++：都可重载，但容器默认行为不同"></a>3.4 Kotlin vs C++：都可重载，但容器默认行为不同</h3><p>C++ 也能重载 <code>operator[]</code>，但很多容器的 <code>operator[]</code> 语义可能是“缺 key 自动插入默认值”（如 <code>std::map</code>）。<br>Kotlin 的 Map <code>[]</code> <strong>不会插入</strong>，它是纯查询；要写入必须显式调用 <code>map[key] = value</code>。</p>
<hr>
<blockquote>
<p>注意</p>
</blockquote>
<ol>
<li><strong>List&#x2F;Array&#x2F;String 的 <code>[]</code> 越界就抛异常</strong>，不像 C 那样“可能悄悄错”。  </li>
<li><strong>Kotlin 没有 Python 那种内建切片</strong>；<code>list[1..3]</code> 不是默认用法。  </li>
<li><strong>Kotlin 的 <code>[]</code> 解析看静态类型</strong>：能不能用、用哪个 <code>get</code>，编译期就决定了。  </li>
<li><strong>Kotlin Map 的 <code>[]</code> 不会像某些 C++ 容器那样访问即插入</strong>。</li>
</ol>
<hr>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4) 总结"></a>4) 总结</h2><ul>
<li>Kotlin 的 <code>[]</code> 是<strong>编译器把语法改写成 <code>operator get/set</code> 调用</strong>。  </li>
<li><code>Map</code> 的 <code>[]</code> 是“查询”，<strong>缺失返回 null</strong>；<code>List/Array/String</code> 的 <code>[]</code> 是“索引”，<strong>越界抛异常</strong>。  </li>
<li>虽然符号相同，但和 C（指针算术）、Java（无重载）、Python（动态 + 切片&#x2F;负索引）相比，<strong>契约差异很大</strong>，跨语言迁移时要特别留意。</li>
</ul>
<hr>
<h3 id="附：自用速查"><a href="#附：自用速查" class="headerlink" title="附：自用速查"></a>附：自用速查</h3><table>
<thead>
<tr>
<th>场景</th>
<th>Kotlin 写法</th>
<th>失败行为</th>
</tr>
</thead>
<tbody><tr>
<td>Map 查值</td>
<td><code>map[key]</code></td>
<td>key 不存在 → <code>null</code></td>
</tr>
<tr>
<td>Map 强制必须存在</td>
<td><code>map.getValue(key)</code></td>
<td>不存在 → 抛异常</td>
</tr>
<tr>
<td>List&#x2F;Array 索引</td>
<td><code>list[i]</code> &#x2F; <code>arr[i]</code></td>
<td>越界 → 抛异常</td>
</tr>
<tr>
<td>安全索引</td>
<td><code>list.getOrNull(i)</code></td>
<td>越界 → <code>null</code></td>
</tr>
<tr>
<td>Set 判断存在</td>
<td><code>x in set</code></td>
<td>返回 <code>true/false</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose Multiplatform 包体积暴涨原因排查记录</title>
    <url>/2026/01/29/package-size-incre-md/</url>
    <content><![CDATA[<h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>2025年12月18日，发现v1.0.3版本桌面端安装包体积爆炸增大，从原本的150MB左右暴涨到1GB，如下图所示。<br><img src="/package-size-incre-md/image.png" alt="image.png"></p>
<p>由于三端均产生该问题，以 macOS 端(.dmg)为例展开排查。解包产物，切入 <code>contents</code> 目录查看文件夹大小，执行 <code>du -sh ./*</code>，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">116K ./Contents/_CodeSignature </span><br><span class="line">999M ./Contents/app </span><br><span class="line">4.0K ./Contents/Info.plist </span><br><span class="line">196K ./Contents/MacOS </span><br><span class="line">4.0K ./Contents/PkgInfo </span><br><span class="line">16K ./Contents/Resources </span><br><span class="line">158M ./Contents/runtime</span><br></pre></td></tr></table></figure>

<p>显然 <strong><code>Contents/app</code>（999MB）</strong> 炸了。这也就是说：这次膨胀原因主要来自 <strong>应用层打包进去的 jar&#x2F;依赖&#x2F;资源</strong> 异常地多，初步怀疑是某个库发生了问题，将三份native包全都打包到一个native平台上了。</p>
<p>切入 <code>Contents/app</code> 执行 <code>du -sh ./*</code> ，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">22M	./opencv-4.6.0-1.5.8-android-x86-b38c986c415ad7d34111fa1ff684a19a.jar</span><br><span class="line">26M	./opencv-4.6.0-1.5.8-ios-arm64-5a95a9fd33b458cf8dc8538fff16.jar</span><br><span class="line">28M	./opencv-4.6.0-1.5.8-ios-x86_64-d3cdf6cb93ba33f2240a97fd5193.jar</span><br><span class="line">24M	./opencv-4.6.0-1.5.8-linux-arm64-91b0d28db0dcbe847ead233f99a2831.jar</span><br><span class="line">22M	./opencv-4.6.0-1.5.8-linux-armhf-4d45d47f293943abde4163761b744fc.jar</span><br><span class="line">27M	./opencv-4.6.0-1.5.8-linux-ppc64le-511dfd3698bebebd724d4052e6a34b90.jar</span><br><span class="line">27M	./opencv-4.6.0-1.5.8-linux-x86_64-91c04431ec13e27014c25b8f77ece6.jar</span><br><span class="line">28M	./opencv-4.6.0-1.5.8-linux-x86-941136bbfad2956a86b10f9242fad34.jar</span><br><span class="line">20M	./opencv-4.6.0-1.5.8-macosx-arm64-699b23fa8d64ced8f96a65d012ff48.jar</span><br><span class="line">25M	./opencv-4.6.0-1.5.8-macosx-x86_64-855f22d26a3e7eb65122adacf1e5cee4.jar</span><br><span class="line">29M	./opencv-4.6.0-1.5.8-windows-x86_64-149da917d80e13db6cac72fd53170cc.jar</span><br><span class="line">27M	./opencv-4.6.0-1.5.8-windows-x86-e136927b1d9446f968ea2bd45dfa13e.jar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这就很显然了，验证了猜想是对的。明明是macOS平台的包，却连 windows 及 linux 的jar都被打包进来，所以导致了包体积暴涨。下一步是排查最终的罪魁祸首，是谁干了这件蠢事。回到项目中运行 <code>./gradlew :composeApp:dependencyInsight --configuration desktopRuntimeClasspath --dependency javacv-platform</code>，输出如下：</p>
<p><img src="/package-size-incre-md/image-1.png" alt="image-1.png"></p>
<p>水落石出，结果显示是 <code>cmp-image-pick-n-crop-jvm:1.1.2</code> 这个库依赖 <code>org.bytedeco:javacv-platform:1.5.8</code> 又依赖 <code>org.bytedeco:opencv-platform:4.6.0-1.5.8</code>。<code>cmp-image-pick-n-crop</code> 是我在Github上找的一个用来裁剪图片的第三方库，它的JVM平台包依赖了 <code>*-platform</code> 全家桶，导致暴增。我在本次更新的改动中将其版本从 <code>1.1.1</code> 升级到 <code>1.1.2</code> 才出现这个问题，看来是作者在更新他的库依赖时犯了个低级错误。</p>
<p>修复很简单，回退到 <code>1.1.1</code> 即可解决，但是治标不治本。本着开源精神至上的原则我把该库fork并拉了下来准备直接修并提PR，结果这才发现这是个假开源项目。源代码是空的，只有个示例app。对印度人的刻板印象再次加深。无奈只好提了个issue作罢，但估计也不会被理睬，看commit日期这个库已经被放弃维护了，令人感叹。</p>
<h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>2026年1月28日，发现v1.0.4版本桌面端安装包体积再次出现异常增大，但这次涨幅不如上次，且只有 Win &#x2F; Linux 平台受影响。</p>
<p><img src="/package-size-incre-md/image-2.png" alt="image-2.png"></p>
<p>这次以 Linux 平台 (.deb) 为例进行排查，还是老方法，解包然后看谁变大了。分别对新老版本安装包运行 <code>du -h -d 4 old | sort -h | tail -n 30</code> 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># old</span><br><span class="line">4.0K    old/opt/bandoristationm/share</span><br><span class="line">4.0K    old/opt/bandoristationm/share/doc</span><br><span class="line"> 20K    old/opt/bandoristationm/bin</span><br><span class="line">129M    old/opt/bandoristationm/lib/app</span><br><span class="line">168M    old/opt/bandoristationm/lib/runtime</span><br><span class="line">298M    old</span><br><span class="line">298M    old/opt</span><br><span class="line">298M    old/opt/bandoristationm</span><br><span class="line">298M    old/opt/bandoristationm/lib</span><br><span class="line"></span><br><span class="line"># new</span><br><span class="line">4.0K    new/opt/bandoristationm/share</span><br><span class="line">4.0K    new/opt/bandoristationm/share/doc</span><br><span class="line"> 24K    new/opt/bandoristationm/bin</span><br><span class="line">129M    new/opt/bandoristationm/lib/app</span><br><span class="line">480M    new/opt/bandoristationm/lib/runtime</span><br><span class="line">610M    new</span><br><span class="line">610M    new/opt</span><br><span class="line">610M    new/opt/bandoristationm</span><br><span class="line">610M    new/opt/bandoristationm/lib</span><br></pre></td></tr></table></figure>

<p><code>lib/runtime</code> 炸了，显然这次不是依赖包的问题，而是JRE出了差错，就像没被裁剪一样。在新版本包中运行 <code>find new/opt/bandoristationm/lib/runtime/lib -type f -print0 | xargs -0 ls -lnS | head -n 30</code>，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r--  1 501  20  209861688 Jan 28 17:05 new/opt/bandoristationm/lib/runtime/lib/libcef.so</span><br><span class="line">-rw-r--r--  1 501  20  147634191 Jan 28 17:05 new/opt/bandoristationm/lib/runtime/lib/modules</span><br><span class="line">-rw-r--r--  1 501  20   26726528 Jan 28 17:05 new/opt/bandoristationm/lib/runtime/lib/server/libjvm.so</span><br><span class="line">-rw-r--r--  1 501  20   10717392 Jan 28 17:05 new/opt/bandoristationm/lib/runtime/lib/icudtl.dat</span><br><span class="line">-rw-r--r--  1 501  20   10715134 Jan 28 17:05 new/opt/bandoristationm/lib/runtime/lib/ct.sym</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一上来就看懂了，怎么混进来个庞然大物 <code>libcef.so</code>，我这是不知道被谁塞了整套 Chromium 啊。翻了翻过去的 commit 记录，定位了罪魁祸首：在 Android Studio 建议迁移 gradle 后，gradle 在升级到9.0.0的同时，顺手给我塞了个 <code>gradle-daemon-jvm.properties</code>。我没有在意，但是这个配置文件里面设置了 <code>toolchainVendor=JETBRAINS</code>，即指定 JBR 为 Gradle Daemon 的运行时，而上面的URL里面又指定了 JBR 的版本是带 JCEF 的版本：</p>
<ul>
<li>Linux: <code>jbrsdk_jcef-21.0.9-linux-x64-b895.149.tar.gz</code></li>
<li>Windows: <code>jbrsdk_jcef-21.0.9-windows-x64-b895.149.zip</code></li>
<li>macOS: <code>jbrsdk_jcef-21.0.9-osx-aarch64-b895.149.tar.gz</code></li>
</ul>
<p>这也导致当workflow在跑时，Gradle构建时，不会再用我指定的 temurin，而是现场下带JCEF 的 JBR 用，自然打包时把 libcef.so 等一系列不需要的东西也拐进来了。</p>
<p>解决：直接rollback即可。</p>
<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>遇到包体积暴涨不用慌，凡事皆有迹可循。桌面端打包（Compose Desktop&#x2F;jpackage）有个特点：<strong>最终体积主要由两部分决定</strong>：</p>
<ul>
<li><strong>应用层</strong>：<code>lib/app</code>（jar、资源、代码）-&gt; 通常增长是渐进的</li>
<li><strong>运行时层</strong>：<code>lib/runtime</code>（JRE&#x2F;JBR、native、资源包）-&gt; <strong>一旦策略变了就是断崖式增长</strong></li>
</ul>
<p>不要用“总大小”当指标，而是要抓“结构”，把体积拆成可解释的结构指标，迅速归因：</p>
<ul>
<li><code>app</code> 变大 → 依赖&#x2F;资源&#x2F;重复打包</li>
<li><code>runtime</code> 变大 → JDK&#x2F;JBR 变更、jlink 失效、引入 JCEF、debug 符号等</li>
</ul>
]]></content>
      <categories>
        <category>Compose Multiplatform</category>
      </categories>
      <tags>
        <tag>Compose Multiplatform</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin的基本类型与装箱机制简析</title>
    <url>/2026/01/30/kotlin-primitive-md/</url>
    <content><![CDATA[<blockquote>
<p>本文从 Kotlin 的基本类型出发，深入探讨数值字面量的实现原理，并全面剖析 Kotlin 与 Java 中的装箱&#x2F;拆箱机制，力求做到知其然知其所以然。</p>
</blockquote>
<hr>
<h2 id="一、Kotlin-基本类型概览"><a href="#一、Kotlin-基本类型概览" class="headerlink" title="一、Kotlin 基本类型概览"></a>一、Kotlin 基本类型概览</h2><p>Kotlin 作为一门现代 JVM 语言，对基本类型的处理既保留了 Java 的高效性，又增添了更优雅的语法设计。与 Java 区分原始类型和包装类的理念不同，Kotlin 中<strong>一切皆对象</strong>——没有原始类型（primitive types）的概念，但编译器会在底层自动优化为 JVM 原始类型以保证性能。</p>
<h3 id="1-1-数值类型"><a href="#1-1-数值类型" class="headerlink" title="1.1 数值类型"></a>1.1 数值类型</h3><p>Kotlin 提供了多种数值类型，覆盖不同精度需求：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>位宽</strong></th>
<th><strong>取值范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Byte</code></td>
<td>8 位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>Short</code></td>
<td>16 位</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td><code>Int</code></td>
<td>32 位</td>
<td>$-2^{31}$ ~ 2^{31}-1</td>
</tr>
<tr>
<td><code>Long</code></td>
<td>64 位</td>
<td>$-2^{63}$ ~ $2^{63}-1$</td>
</tr>
<tr>
<td><code>Float</code></td>
<td>32 位</td>
<td>单精度浮点</td>
</tr>
<tr>
<td><code>Double</code></td>
<td>64 位</td>
<td>双精度浮点</td>
</tr>
<tr>
<td>注：<code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code> 还具有对应无符号类型：<code>UByte</code>, <code>UShort</code>, <code>UInt</code>, <code>ULong</code>。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>字面量写法：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intNum = <span class="number">100</span>          <span class="comment">// 默认推断为 Int</span></span><br><span class="line"><span class="keyword">val</span> longNum = <span class="number">100L</span>        <span class="comment">// L 后缀表示 Long</span></span><br><span class="line"><span class="keyword">val</span> floatNum = <span class="number">3.14f</span>      <span class="comment">// f 后缀表示 Float</span></span><br><span class="line"><span class="keyword">val</span> doubleNum = <span class="number">3.14</span>      <span class="comment">// 默认推断为 Double</span></span><br><span class="line"><span class="keyword">val</span> hexNum = <span class="number">0xFF</span>         <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">val</span> binaryNum = <span class="number">0b1010</span>    <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">val</span> readable = <span class="number">1_000_000</span>  <span class="comment">// 支持下划线分隔，提升可读性</span></span><br></pre></td></tr></table></figure>

<p><strong>显式类型转换：</strong> ⚠️Kotlin 不支持隐式类型转换，必须显式调用转换函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = i.toLong()  <span class="comment">// ✅ 正确</span></span><br><span class="line"><span class="comment">// val l: Long = i        // ❌ 编译错误</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-1-Number-类"><a href="#1-1-1-Number-类" class="headerlink" title="1.1.1 Number 类"></a>1.1.1 Number 类</h4><p>以上数值类型都有一个共同的父类：<code>Number</code>，这是一个抽象类，并定义了一系列显示类型转换函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Number</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toDouble</span><span class="params">()</span></span>: <span class="built_in">Double</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toFloat</span><span class="params">()</span></span>: <span class="built_in">Float</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toLong</span><span class="params">()</span></span>: <span class="built_in">Long</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toInt</span><span class="params">()</span></span>: <span class="built_in">Int</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toChar</span><span class="params">()</span></span>: <span class="built_in">Char</span>  <span class="comment">// Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toShort</span><span class="params">()</span></span>: <span class="built_in">Short</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">toByte</span><span class="params">()</span></span>: <span class="built_in">Byte</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过继承 <code>Number</code>类并实现 <code>Comparable</code>接口，派生出以上数值类型。</p>
<h3 id="1-2-字符与字符串"><a href="#1-2-字符与字符串" class="headerlink" title="1.2 字符与字符串"></a>1.2 字符与字符串</h3><p><code>Char</code> 表示单个字符（16-bit Unicode），用单引号包裹；字符串用双引号或三引号表示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> letter: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;Hello, Kotlin&quot;</span></span><br><span class="line"><span class="keyword">val</span> multiLine = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是多行字符串</span></span><br><span class="line"><span class="string">    保留原始格式</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.trimIndent()</span><br></pre></td></tr></table></figure>

<p>注意 <code>Char</code> 与数值类型互转的方法，直接调用 <code>toChar()</code>或 <code>toLong()</code>等已经弃用，需要以 <code>Int</code>类型作为媒介：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> char: <span class="built_in">Char</span> = <span class="string">&#x27;A&#x27;</span>  </span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = char.code <span class="comment">// Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.  </span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = char.code.toLong()  </span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Char</span> = i.toChar() <span class="comment">// significant 16 bits of this Int value.  </span></span><br><span class="line"><span class="keyword">val</span> d: <span class="built_in">Char</span> = i.digitToChar() <span class="comment">// decimal digit</span></span><br></pre></td></tr></table></figure>

<p>Kotlin 支持<strong>字符串模板</strong>，这在构造特定字符串以及日志打印等场景都非常好用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;World&quot;</span></span><br><span class="line">println(<span class="string">&quot;Hello, <span class="variable">$name</span>!&quot;</span>)           <span class="comment">// 简单变量</span></span><br><span class="line">println(<span class="string">&quot;长度是 <span class="subst">$&#123;name.length&#125;</span>&quot;</span>)    <span class="comment">// 表达式</span></span><br></pre></td></tr></table></figure>

<p>Kotlin String 还有更多值得说道的知识点，在此先略过，之后另写一篇博客来详细探讨。</p>
<h3 id="1-3-布尔类型与数组"><a href="#1-3-布尔类型与数组" class="headerlink" title="1.3 布尔类型与数组"></a>1.3 布尔类型与数组</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> isKotlinFun: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型数组</span></span><br><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始类型数组（避免装箱开销）</span></span><br><span class="line"><span class="keyword">val</span> intArr = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、数值字面量的实现机制"><a href="#二、数值字面量的实现机制" class="headerlink" title="二、数值字面量的实现机制"></a>二、数值字面量的实现机制</h2><p>既然 Kotlin 中 <code>Int</code> 是一个类，为什么 <code>val x = 1</code> 不需要写成 <code>val x = Int(1)</code> 这样的构造函数形式？</p>
<h3 id="2-1-字面量是语言级别的语法糖"><a href="#2-1-字面量是语言级别的语法糖" class="headerlink" title="2.1 字面量是语言级别的语法糖"></a>2.1 字面量是语言级别的语法糖</h3><p>数值字面量是 Kotlin 语言规范直接支持的特殊语法，编译器看到 <code>1</code> 时，直接将其识别为 <code>Int</code> 类型的字面量常量，<strong>不需要</strong>经过任何构造函数调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span>        <span class="comment">// 字面量语法，编译器直接处理</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="built_in">Int</span>(<span class="number">1</span>)   <span class="comment">// ❌ 编译错误！Int 没有公开构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-为什么-Int-没有构造函数？"><a href="#2-2-为什么-Int-没有构造函数？" class="headerlink" title="2.2 为什么 Int 没有构造函数？"></a>2.2 为什么 Int 没有构造函数？</h3><p>Kotlin 的数值类型是<strong>特殊的内置类型</strong>，构造函数是私有的：</p>
<table>
<thead>
<tr>
<th><strong>设计原因</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>性能优化</td>
<td>编译器可以直接映射到 JVM 原始类型，无需真正的对象分配</td>
</tr>
<tr>
<td>语义清晰</td>
<td><code>1</code> 就是 <code>1</code>，不需要 <code>new Integer(1)</code> 的冗余</td>
</tr>
<tr>
<td>防止滥用</td>
<td>避免 <code>Int(someString)</code> 这种容易出错的用法</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-3-编译过程示例"><a href="#2-3-编译过程示例" class="headerlink" title="2.3 编译过程示例"></a>2.3 编译过程示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────┐</span><br><span class="line">│  Kotlin 源码        val x = 1                       │</span><br><span class="line">├─────────────────────────────────────────────────────┤</span><br><span class="line">│  编译器理解          x 是 Int 类型，值为字面量 1      │</span><br><span class="line">├─────────────────────────────────────────────────────┤</span><br><span class="line">│  字节码输出          ICONST_1  (JVM 原始 int 指令)   │</span><br><span class="line">│                     ISTORE x                        │</span><br><span class="line">└─────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>反编译为 Java 代码，就是简单的 <code>int x = 1;</code>——直接是原始类型，零开销。</p>
<hr>
<h2 id="三、Kotlin-中的装箱机制"><a href="#三、Kotlin-中的装箱机制" class="headerlink" title="三、Kotlin 中的装箱机制"></a>三、Kotlin 中的装箱机制</h2><p>虽然 Kotlin 在语法层面”隐藏”了装箱的概念，但<strong>装箱并不是就消失了</strong>——只是编译器帮我们自动处理了。</p>
<h3 id="3-1-什么时候会发生装箱？"><a href="#3-1-什么时候会发生装箱？" class="headerlink" title="3.1 什么时候会发生装箱？"></a>3.1 什么时候会发生装箱？</h3><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>是否装箱</strong></th>
<th><strong>底层类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>val x: Int = 1</code></td>
<td>❌ 不装箱</td>
<td>JVM <code>int</code></td>
</tr>
<tr>
<td><code>val x: Int? = 1</code></td>
<td>✅ 装箱</td>
<td>JVM <code>Integer</code></td>
</tr>
<tr>
<td><code>val list: List&lt;Int&gt;</code></td>
<td>✅ 装箱</td>
<td><code>List&lt;Integer&gt;</code></td>
</tr>
<tr>
<td><code>fun foo(x: Any)</code> 传入 <code>Int</code></td>
<td>✅ 装箱</td>
<td><code>Object</code></td>
</tr>
<tr>
<td><code>val arr: IntArray</code></td>
<td>❌ 不装箱</td>
<td>JVM <code>int[]</code></td>
</tr>
<tr>
<td><code>val arr: Array&lt;Int&gt;</code></td>
<td>✅ 装箱</td>
<td>JVM <code>Integer[]</code></td>
</tr>
</tbody></table>
<h3 id="3-2-可空类型必须装箱"><a href="#3-2-可空类型必须装箱" class="headerlink" title="3.2 可空类型必须装箱"></a>3.2 可空类型必须装箱</h3><p>JVM 原始类型无法表示 null，所以可空数值必须用包装类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span>      <span class="comment">// 底层: int</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Int</span>? = <span class="number">1</span>     <span class="comment">// 底层: Integer（才能存 null）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-泛型强制装箱"><a href="#3-3-泛型强制装箱" class="headerlink" title="3.3 泛型强制装箱"></a>3.3 泛型强制装箱</h3><p>JVM 的泛型使用类型擦除，不支持原始类型作为类型参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment">// List&lt;Int&gt; → List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">// 每个元素都被装箱了！</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-Array-vs-IntArray"><a href="#3-4-Array-vs-IntArray" class="headerlink" title="3.4 Array&lt;Int&gt; vs IntArray"></a>3.4 Array&lt;Int&gt; vs IntArray</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装箱数组</span></span><br><span class="line"><span class="keyword">val</span> boxed: Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 底层: Integer[] &#123;Integer.valueOf(1), Integer.valueOf(2), ...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始类型数组</span></span><br><span class="line"><span class="keyword">val</span> primitive: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 底层: int[] &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>内存布局差异：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array&lt;Int&gt; (装箱)                    IntArray (原始)</span><br><span class="line">┌─────────────────┐                 ┌─────────────────┐</span><br><span class="line">│ Integer 引用 ──────→ [Integer 对象] │ int: 1          │</span><br><span class="line">│ Integer 引用 ──────→ [Integer 对象] │ int: 2          │</span><br><span class="line">│ Integer 引用 ──────→ [Integer 对象] │ int: 3          │</span><br><span class="line">└─────────────────┘                 └─────────────────┘</span><br><span class="line">   额外的对象开销 + 指针跳转              连续内存，零开销</span><br></pre></td></tr></table></figure>

<p>所以多使用诸如 <code>IntArray</code>的原始数据类型数组可以避免装箱开销，算是 Kotlin 使用的基本技巧。</p>
<hr>
<h2 id="四、Java-中的装箱机制"><a href="#四、Java-中的装箱机制" class="headerlink" title="四、Java 中的装箱机制"></a>四、Java 中的装箱机制</h2><p>Java 的装箱机制比 Kotlin 更”显眼”——因为 Java <strong>明确区分原始类型和包装类</strong>。</p>
<h3 id="4-1-原始类型-vs-包装类"><a href="#4-1-原始类型-vs-包装类" class="headerlink" title="4.1 原始类型 vs 包装类"></a>4.1 原始类型 vs 包装类</h3><table>
<thead>
<tr>
<th><strong>原始类型</strong></th>
<th><strong>包装类</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="4-2-自动装箱与拆箱"><a href="#4-2-自动装箱与拆箱" class="headerlink" title="4.2 自动装箱与拆箱"></a>4.2 自动装箱与拆箱</h3><p>Java 5 引入了自动装箱，让两种类型可以”无缝”转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装箱：int → Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 编译器转换为: Integer.valueOf(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱：Integer → int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;        <span class="comment">// 编译器转换为: x.intValue()</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-装箱的经典陷阱"><a href="#4-3-装箱的经典陷阱" class="headerlink" title="4.3 装箱的经典陷阱"></a>4.3 装箱的经典陷阱</h3><p><strong>陷阱一：&#x3D;&#x3D; 比较的诡异行为（面试常考）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true ✅</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d);  <span class="comment">// false ❌</span></span><br></pre></td></tr></table></figure>

<p>原因是 <code>Integer.valueOf()</code> 对 -128 ~ 127 范围内的值使用了缓存池，超出范围则创建新对象。<strong>比较值永远用 <code>equals()</code>！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];  <span class="comment">// 返回缓存对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);  <span class="comment">// 超出范围，创建新对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>陷阱二：NullPointerException</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;  <span class="comment">// 💥 NullPointerException!</span></span><br><span class="line"><span class="comment">// 因为实际执行的是: x.intValue()</span></span><br></pre></td></tr></table></figure>

<p><strong>陷阱三：循环中的性能杀手</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的写法：每次迭代都装箱</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    sum += i;  <span class="comment">// 拆箱 → 相加 → 装箱，创建大量临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确的写法</span></span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    sum += i;  <span class="comment">// 纯原始类型操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-内存开销对比"><a href="#4-4-内存开销对比" class="headerlink" title="4.4 内存开销对比"></a>4.4 内存开销对比</h3><ul>
<li>原始类型 int: 4 bytes</li>
<li>包装类 Integer:   对象头 (12 bytes) + value (4 bytes) + 对齐 ≈ 16 bytes + 引用指针 4-8 bytes</li>
</ul>
<p><strong>可见一个 Integer 比 int 多占用约 4-5 倍内存！</strong></p>
<hr>
<h2 id="五、Kotlin-vs-Java-装箱对比"><a href="#五、Kotlin-vs-Java-装箱对比" class="headerlink" title="五、Kotlin vs Java 装箱对比"></a>五、Kotlin vs Java 装箱对比</h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Java</strong></th>
<th><strong>Kotlin</strong></th>
</tr>
</thead>
<tbody><tr>
<td>类型区分</td>
<td>显式区分 <code>int</code> &#x2F; <code>Integer</code></td>
<td>统一为 <code>Int</code>，编译器决定</td>
</tr>
<tr>
<td>装箱语法</td>
<td>可见 (<code>Integer x = 1</code>)</td>
<td>隐藏 (<code>val x: Int? = 1</code>)</td>
</tr>
<tr>
<td>null 安全</td>
<td>运行时抛异常</td>
<td>编译期检查</td>
</tr>
<tr>
<td>原始数组</td>
<td><code>int[]</code></td>
<td><code>IntArray</code></td>
</tr>
<tr>
<td>包装数组</td>
<td><code>Integer[]</code></td>
<td><code>Array&lt;Int&gt;</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java：你必须自己选择</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;        <span class="comment">// 原始类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 包装类（自动装箱）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin：编译器帮你选择</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span>    <span class="comment">// 底层是 int</span></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Int</span>? = <span class="number">1</span>   <span class="comment">// 底层是 Integer（因为可空）</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、最佳实践"><a href="#六、最佳实践" class="headerlink" title="六、最佳实践"></a>六、最佳实践</h2><h3 id="Kotlin-最佳实践"><a href="#Kotlin-最佳实践" class="headerlink" title="Kotlin 最佳实践"></a>Kotlin 最佳实践</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 尽量用非空类型</span></span><br><span class="line"><span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">1</span>      <span class="comment">// ✅ 底层是 int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数值数组用原始类型版本</span></span><br><span class="line"><span class="keyword">val</span> arr = IntArray(<span class="number">1000</span>)       <span class="comment">// ✅ int[]</span></span><br><span class="line"><span class="keyword">val</span> arr = Array&lt;<span class="built_in">Int</span>&gt;(<span class="number">1000</span>)&#123;<span class="number">0</span>&#125;  <span class="comment">// ❌ Integer[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 性能敏感场景注意泛型集合的装箱开销</span></span><br></pre></td></tr></table></figure>

<h3 id="Java-最佳实践"><a href="#Java-最佳实践" class="headerlink" title="Java 最佳实践"></a>Java 最佳实践</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 优先使用原始类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较包装类用 equals()</span></span><br><span class="line"><span class="keyword">if</span> (integer1.equals(integer2)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 拆箱前检查 null</span></span><br><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value &gt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 避免在循环中使用包装类做累加</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>理解类型系统和装箱机制，是写出高质量 JVM 代码的基础：</p>
<ul>
<li><strong>Kotlin</strong> 通过统一的类型语法和空安全设计，将装箱的复杂性隐藏在编译器背后，让开发者专注于业务逻辑</li>
<li><strong>Java</strong> 的显式双轨制要求开发者时刻意识到原始类型和包装类的区别，避免性能陷阱和 NPE</li>
</ul>
<p>无论使用哪种语言，记住一个原则即可：<strong>在性能敏感的场景下，优先使用原始类型；在需要对象语义的场景下，注意装箱的开销和空值处理</strong>。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
</search>
